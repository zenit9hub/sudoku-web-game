{"version":3,"mappings":"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","names":["GameStatus","Difficulty","GameState","id","difficulty","status","statistics","selectedCell","row","col","SudokuGame","_grid","_initialGrid","_state","createdAt","updatedAt","grid","state","defaultState","_CellValue","value","other","_a","CellValue","Cell","position","_value","_options","highlighted","hasError","Position","_SudokuGrid","cells","_","newCells","rowIndex","colIndex","boxIndex","startRow","startCol","boxCells","cell","counts","i","currentCounts","remainingCounts","used","SudokuGrid","SudokuValidationService","conflictingPositions","conflicts","possibleValues","cellValue","SudokuGeneratorService","seed","options","completeSolution","randomizedSolution","firstRow","newGrid","initialGrid","emptyCells","shuffledValues","result","_symmetric","cellsToRemove","positions","shuffledPositions","currentGrid","removedCount","array","shuffled","j","values","substitution","newValue","numbers","EffectType","EffectAnimation","EffectState","_LineCompletionEffect","type","animation","lineIndex","cellPositions","startTime","cellEffects","completionPosition","index","currentTime","updatedCellEffects","cellEffect","timeSinceStart","stepIndex","newState","effect","constructor","progress","scale","opacity","LineCompletionEffect","_LinearEffect","cellIndex","baseStartTime","LinearEffect","_RadialEffect","cellPosition","distance","randomOffset","cellsByDistance","RadialEffect","EffectSequenceId","timestamp","random","SequenceState","EffectDomainEvent","aggregateId","eventType","EffectSequenceStarted","sequenceId","effectCount","EffectSequence","effects","currentEffectIndex","completedCount","defaultOptions","newEffects","startedSequence","updatedEffects","updatedCurrentEffect","nextIndex","nextEffect","_currentTime","newCompletedCount","repeatCount","resetEffects","current","event","EffectFactory","delayBetweenEffects","completedLines","line","cascadeDelay","lineType","effectAnimation","LineCompletionDetectionService","lastMovePosition","completions","completion","column","BaseDomainEvent","aggregateType","data","GameStarted","gameId","metadata","MoveAttempted","isValid","pos","ValidMoveCompleted","moveCount","InvalidMoveAttempted","mistakeCount","GameCompleted","finalStats","GamePaused","GameResumed","HintRequested","suggestedValue","GameReset","BusinessRuleEngine","rule","rules","ruleName","context","violatedRules","r","predicate","applicableRules","a","b","BaseBusinessRule","name","description","priority","CannotModifyGivenCellRule","UniqueInRowRule","UniqueInColumnRule","UniqueInBoxRule","boxStartRow","boxStartCol","boxRow","boxCol","ValidCellValueRule","ValidPositionRule","GameInProgressRule","MaxMistakesRule","maxMistakes","_context","SudokuRuleFactory","engine","NakedSingleRule","possible","num","testValue","rowRule","colRule","boxRule","HiddenSingleRule","possiblePositions","testContext","EnhancedGridValidationService","eventPublisher","gameState","ruleResult","suggestions","validationResult","vr","filledCells","seen","allErrors","allViolatedRules","allConflictingPositions","invalidReasons","basicEngine","__vitePreload","SudokuBusinessRules","reasons","boxNum","possibleInRow","possibleInCol","possibleInBox","unique","key","GameService","gameRepository","validationService","game","validation","updatedGame","isComplete","lineCompletionEffects","finalGame","success","hintValue","randomCell","resetGame","puzzle","LocalStorageGameRepository","serialized","gameIds","error","gameKey","stateKey","filteredIds","serializedGrid","serializedCell","BoardRenderer","ctx","cellSize","gridSize","backgroundColor","borderColor","subGridBorderColor","SelectionEffectsRenderer","selectedRow","selectedCol","selectedValue","allCellsWithNumbers","matchingCells","x","y","gradient","elapsed","pulseValue","dynamicOpacity","dynamicIntensity","pulseEffect","LineCompletionEffectsRenderer","centerX","centerY","scaledSize","scaledX","scaledY","baseColor","CanvasGameRenderer","canvas","renderOptions","width","height","boardOptions","shouldHighlightNumber","isHighlighted","textColor","selectionOptions","cellsWithNumbers","startedEffects","effectOptions","GameController","gameService","renderer","events","hint","count","lastFrameTime","frameInterval","animate","DOMElementManager","elementId","element","selector","content","property","styles","DOM_SELECTORS","EventManager","gameController","domManager","CanvasEventHandler","KeyboardEventHandler","ButtonEventHandler","rect","target","number","handler","button","APP_CONFIG","UI_COLORS","MESSAGES","time","moves","hints","UIManager","currentElapsedTime","stats","updates","selectionInfo","message","color","duration","finalTime","update","formattedTime","remaining","buttonSelector","countSelector","countElement","buttonElement","formatTime","seconds","mins","secs","TimerManager","onTimeUpdate","elapsedSeconds","SudokuApp","resizeGame","canvasSize","devicePixelRatio","internalSize","currentGame"],"sources":["../../src/domain/sudoku/entities/GameState.ts","../../src/domain/sudoku/aggregates/Game.ts","../../src/domain/sudoku/value-objects/CellValue.ts","../../src/domain/sudoku/entities/Cell.ts","../../src/domain/sudoku/value-objects/Position.ts","../../src/domain/sudoku/aggregates/Grid.ts","../../src/domain/sudoku/services/GridValidationService.ts","../../src/domain/sudoku/services/PuzzleGenerationService.ts","../../src/domain/effects/value-objects/EffectType.ts","../../src/domain/effects/value-objects/EffectAnimation.ts","../../src/domain/effects/value-objects/EffectState.ts","../../src/domain/effects/entities/LineCompletionEffect.ts","../../src/domain/effects/entities/LinearEffect.ts","../../src/domain/effects/entities/RadialEffect.ts","../../src/domain/effects/value-objects/EffectSequenceId.ts","../../src/domain/effects/value-objects/SequenceState.ts","../../src/domain/effects/events/EffectDomainEvent.ts","../../src/domain/effects/aggregates/EffectSequence.ts","../../src/domain/effects/services/EffectFactory.ts","../../src/domain/sudoku/services/CompletionDetectionService.ts","../../src/domain/common/events/DomainEvent.ts","../../src/domain/sudoku/events/SudokuDomainEvents.ts","../../src/domain/common/rules/BusinessRule.ts","../../src/domain/sudoku/rules/SudokuBusinessRules.ts","../../src/domain/sudoku/services/EnhancedGridValidationService.ts","../../src/application/services/GameService.ts","../../src/infrastructure/repositories/LocalStorageGameRepository.ts","../../src/presentation/renderers/BoardRenderer.ts","../../src/presentation/renderers/SelectionEffectsRenderer.ts","../../src/presentation/renderers/LineCompletionEffectsRenderer.ts","../../src/presentation/renderers/CanvasGameRenderer.ts","../../src/presentation/controllers/GameController.ts","../../src/presentation/managers/DOMElementManager.ts","../../src/presentation/config/DOMSelectors.ts","../../src/presentation/managers/EventManager.ts","../../src/presentation/config/AppConfig.ts","../../src/presentation/managers/UIManager.ts","../../src/utils/index.ts","../../src/presentation/managers/TimerManager.ts","../../src/main.ts"],"sourcesContent":["export enum GameStatus {\n  INITIAL = 'initial',\n  IN_PROGRESS = 'in_progress',\n  COMPLETED = 'completed',\n  PAUSED = 'paused'\n}\n\nexport enum Difficulty {\n  EASY = 'easy',\n  MEDIUM = 'medium',\n  HARD = 'hard',\n  EXPERT = 'expert'\n}\n\nexport interface GameStatistics {\n  startTime: Date;\n  endTime?: Date;\n  elapsedTime: number;\n  moves: number;\n  hints: number;\n  mistakes: number;\n}\n\nexport class GameState {\n  constructor(\n    public readonly id: string,\n    public readonly difficulty: Difficulty,\n    public readonly status: GameStatus,\n    public readonly statistics: GameStatistics,\n    public readonly selectedCell?: { row: number; col: number }\n  ) {}\n\n  get moveCount(): number {\n    return this.statistics.moves;\n  }\n\n  get mistakeCount(): number {\n    return this.statistics.mistakes;\n  }\n\n  get elapsedTime(): number {\n    return this.statistics.elapsedTime;\n  }\n\n  get isComplete(): boolean {\n    return this.status === GameStatus.COMPLETED;\n  }\n\n  get isPaused(): boolean {\n    return this.status === GameStatus.PAUSED;\n  }\n\n  get gameId(): string {\n    return this.id;\n  }\n\n  get hintsUsed(): number {\n    return this.statistics.hints;\n  }\n\n  get startTime(): number {\n    return this.statistics.startTime.getTime();\n  }\n\n  static create(id: string, difficulty: Difficulty): GameState {\n    return new GameState(\n      id,\n      difficulty,\n      GameStatus.INITIAL,\n      {\n        startTime: new Date(),\n        elapsedTime: 0,\n        moves: 0,\n        hints: 0,\n        mistakes: 0\n      }\n    );\n  }\n\n  static createNew(difficulty?: Difficulty): GameState {\n    return new GameState(\n      '',\n      difficulty || Difficulty.MEDIUM,\n      GameStatus.INITIAL,\n      {\n        startTime: new Date(),\n        elapsedTime: 0,\n        moves: 0,\n        hints: 0,\n        mistakes: 0\n      }\n    );\n  }\n\n  start(): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      GameStatus.IN_PROGRESS,\n      { ...this.statistics, startTime: new Date() },\n      this.selectedCell\n    );\n  }\n\n  complete(): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      GameStatus.COMPLETED,\n      { ...this.statistics, endTime: new Date() },\n      this.selectedCell\n    );\n  }\n\n  pause(): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      GameStatus.PAUSED,\n      this.statistics,\n      this.selectedCell\n    );\n  }\n\n  resume(): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      GameStatus.IN_PROGRESS,\n      this.statistics,\n      this.selectedCell\n    );\n  }\n\n  addMove(): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      this.status,\n      { ...this.statistics, moves: this.statistics.moves + 1 },\n      this.selectedCell\n    );\n  }\n\n  addHint(): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      this.status,\n      { ...this.statistics, hints: this.statistics.hints + 1 },\n      this.selectedCell\n    );\n  }\n\n  addMistake(): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      this.status,\n      { ...this.statistics, mistakes: this.statistics.mistakes + 1 },\n      this.selectedCell\n    );\n  }\n\n  selectCell(row: number, col: number): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      this.status,\n      this.statistics,\n      { row, col }\n    );\n  }\n\n  clearSelection(): GameState {\n    return new GameState(\n      this.id,\n      this.difficulty,\n      this.status,\n      this.statistics,\n      undefined\n    );\n  }\n}","import { SudokuGrid } from './Grid';\nimport { GameState } from '../entities/GameState';\n\nexport class SudokuGame {\n  public readonly createdAt: Date;\n  public readonly updatedAt: Date;\n\n  constructor(\n    public readonly id: string,\n    private readonly _grid: SudokuGrid,\n    private readonly _initialGrid: SudokuGrid,\n    private readonly _state: GameState,\n    createdAt?: Date,\n    updatedAt?: Date\n  ) {\n    this.createdAt = createdAt || new Date();\n    this.updatedAt = updatedAt || new Date();\n  }\n\n  static create(id: string, grid: SudokuGrid, state?: GameState): SudokuGame {\n    const defaultState = state || GameState.createNew();\n    return new SudokuGame(id, grid, grid.clone(), defaultState);\n  }\n\n  get grid(): SudokuGrid {\n    return this._grid;\n  }\n\n  get initialGrid(): SudokuGrid {\n    return this._initialGrid;\n  }\n\n  get state(): GameState {\n    return this._state;\n  }\n\n  updateGrid(grid: SudokuGrid): SudokuGame {\n    return new SudokuGame(\n      this.id,\n      grid,\n      this._initialGrid,\n      this._state,\n      this.createdAt,\n      new Date()\n    );\n  }\n\n  updateState(state: GameState): SudokuGame {\n    return new SudokuGame(\n      this.id,\n      this._grid,\n      this._initialGrid,\n      state,\n      this.createdAt,\n      new Date()\n    );\n  }\n\n  reset(): SudokuGame {\n    return new SudokuGame(\n      this.id,\n      this._initialGrid.clone(),\n      this._initialGrid,\n      GameState.create(this.id, this._state.difficulty),\n      this.createdAt,\n      new Date()\n    );\n  }\n\n  clone(): SudokuGame {\n    return new SudokuGame(\n      this.id,\n      this._grid.clone(),\n      this._initialGrid.clone(),\n      this._state,\n      this.createdAt,\n      this.updatedAt\n    );\n  }\n}","export class CellValue {\n  private static readonly VALID_VALUES = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  \n  constructor(public readonly value: number | null) {\n    this.validateValue(value);\n  }\n\n  private validateValue(value: number | null): void {\n    if (value !== null && !CellValue.VALID_VALUES.has(value)) {\n      throw new Error(`Invalid cell value: ${value}. Must be between 1 and 9 or null.`);\n    }\n  }\n\n  static empty(): CellValue {\n    return new CellValue(null);\n  }\n\n  static from(value: number): CellValue {\n    return new CellValue(value);\n  }\n\n  isEmpty(): boolean {\n    return this.value === null;\n  }\n\n  equals(other: CellValue): boolean {\n    return this.value === other.value;\n  }\n\n  toString(): string {\n    return this.value?.toString() ?? '';\n  }\n\n  toNumber(): number {\n    if (this.value === null) {\n      throw new Error('Cannot convert empty cell value to number');\n    }\n    return this.value;\n  }\n\n  isValid(): boolean {\n    return this.value === null || CellValue.VALID_VALUES.has(this.value);\n  }\n}","import { CellValue } from '../value-objects/CellValue';\nimport { Position } from '../value-objects/Position';\n\nexport interface CellOptions {\n  isGiven?: boolean;\n  isHighlighted?: boolean;\n  hasError?: boolean;\n}\n\nexport class Cell {\n  constructor(\n    public readonly position: Position,\n    private _value: CellValue = CellValue.empty(),\n    private _options: CellOptions = {}\n  ) {}\n\n  get value(): CellValue {\n    return this._value;\n  }\n\n  get isGiven(): boolean {\n    return this._options.isGiven ?? false;\n  }\n\n  get isHighlighted(): boolean {\n    return this._options.isHighlighted ?? false;\n  }\n\n  get hasError(): boolean {\n    return this._options.hasError ?? false;\n  }\n\n  setValue(value: CellValue): Cell {\n    if (this.isGiven) {\n      throw new Error(`Cannot modify given cell at ${this.position.toString()}`);\n    }\n    return new Cell(this.position, value, this._options);\n  }\n\n  setHighlight(highlighted: boolean): Cell {\n    return new Cell(\n      this.position,\n      this._value,\n      { ...this._options, isHighlighted: highlighted }\n    );\n  }\n\n  setError(hasError: boolean): Cell {\n    return new Cell(\n      this.position,\n      this._value,\n      { ...this._options, hasError }\n    );\n  }\n\n  isEmpty(): boolean {\n    return this._value.isEmpty();\n  }\n\n  equals(other: Cell): boolean {\n    return this.position.equals(other.position) && \n           this._value.equals(other._value);\n  }\n}","export class Position {\n  constructor(\n    public readonly row: number,\n    public readonly col: number\n  ) {\n    this.validatePosition(row, col);\n  }\n\n  private validatePosition(row: number, col: number): void {\n    if (row < 0 || row > 8 || col < 0 || col > 8) {\n      throw new Error(`Invalid position: (${row}, ${col}). Must be between 0 and 8.`);\n    }\n  }\n\n  equals(other: Position): boolean {\n    return this.row === other.row && this.col === other.col;\n  }\n\n  toString(): string {\n    return `(${this.row}, ${this.col})`;\n  }\n\n  getBoxIndex(): number {\n    return Math.floor(this.row / 3) * 3 + Math.floor(this.col / 3);\n  }\n\n  isValid(): boolean {\n    return this.row >= 0 && this.row <= 8 && this.col >= 0 && this.col <= 8;\n  }\n}","import { Cell } from '../entities/Cell';\nimport { Position } from '../value-objects/Position';\nimport { CellValue } from '../value-objects/CellValue';\n\nexport class SudokuGrid {\n  private static readonly GRID_SIZE = 9;\n  private readonly cells: Cell[][];\n\n  constructor(cells?: Cell[][]) {\n    if (cells) {\n      this.validateGridSize(cells);\n      this.cells = cells.map(row => [...row]);\n    } else {\n      this.cells = this.createEmptyGrid();\n    }\n  }\n\n  private validateGridSize(cells: Cell[][]): void {\n    if (cells.length !== SudokuGrid.GRID_SIZE || \n        cells.some(row => row.length !== SudokuGrid.GRID_SIZE)) {\n      throw new Error('Grid must be 9x9');\n    }\n  }\n\n  private createEmptyGrid(): Cell[][] {\n    return Array.from({ length: SudokuGrid.GRID_SIZE }, (_, row) =>\n      Array.from({ length: SudokuGrid.GRID_SIZE }, (_, col) =>\n        new Cell(new Position(row, col))\n      )\n    );\n  }\n\n  getCell(position: Position): Cell {\n    return this.cells[position.row][position.col];\n  }\n\n  setCell(position: Position, value: CellValue): SudokuGrid {\n    const newCells = this.cells.map(row => [...row]);\n    newCells[position.row][position.col] = \n      this.getCell(position).setValue(value);\n    return new SudokuGrid(newCells);\n  }\n\n  getRow(rowIndex: number): Cell[] {\n    return [...this.cells[rowIndex]];\n  }\n\n  getColumn(colIndex: number): Cell[] {\n    return this.cells.map(row => row[colIndex]);\n  }\n\n  getBox(boxIndex: number): Cell[] {\n    const startRow = Math.floor(boxIndex / 3) * 3;\n    const startCol = (boxIndex % 3) * 3;\n    \n    const boxCells: Cell[] = [];\n    for (let row = startRow; row < startRow + 3; row++) {\n      for (let col = startCol; col < startCol + 3; col++) {\n        boxCells.push(this.cells[row][col]);\n      }\n    }\n    return boxCells;\n  }\n\n  getAllCells(): Cell[] {\n    return this.cells.flat();\n  }\n\n  clone(): SudokuGrid {\n    return new SudokuGrid(this.cells);\n  }\n\n  isEmpty(): boolean {\n    return this.getAllCells().every(cell => cell.isEmpty());\n  }\n\n  isFull(): boolean {\n    return this.getAllCells().every(cell => !cell.isEmpty());\n  }\n\n  /**\n   * Get all empty cells (non-given, non-filled)\n   */\n  getEmptyCells(): Cell[] {\n    return this.getAllCells().filter(cell => cell.isEmpty() && !cell.isGiven);\n  }\n\n  /**\n   * Get all given cells (pre-filled cells from puzzle)\n   */\n  getGivenCells(): Cell[] {\n    return this.getAllCells().filter(cell => cell.isGiven);\n  }\n\n  /**\n   * Get all filled cells (have values)\n   */\n  getFilledCells(): Cell[] {\n    return this.getAllCells().filter(cell => !cell.isEmpty());\n  }\n\n  /**\n   * Get count of filled cells\n   */\n  getFilledCellCount(): number {\n    return this.getFilledCells().length;\n  }\n\n  /**\n   * Get count of each number (1-9) currently placed in the grid\n   */\n  getNumberCounts(): Map<number, number> {\n    const counts = new Map<number, number>();\n\n    // Initialize counts for numbers 1-9\n    for (let i = 1; i <= 9; i++) {\n      counts.set(i, 0);\n    }\n\n    // Count occurrences of each number\n    this.getAllCells().forEach(cell => {\n      if (!cell.isEmpty()) {\n        const value = cell.value.toNumber();\n        counts.set(value, (counts.get(value) || 0) + 1);\n      }\n    });\n\n    return counts;\n  }\n\n  /**\n   * Get remaining count for each number (how many more can be placed)\n   */\n  getRemainingCounts(): Map<number, number> {\n    const currentCounts = this.getNumberCounts();\n    const remainingCounts = new Map<number, number>();\n\n    for (let i = 1; i <= 9; i++) {\n      const used = currentCounts.get(i) || 0;\n      remainingCounts.set(i, Math.max(0, 9 - used));\n    }\n\n    return remainingCounts;\n  }\n}","import { SudokuGrid } from '../aggregates/Grid';\nimport { Position } from '../value-objects/Position';\nimport { CellValue } from '../value-objects/CellValue';\n\nexport interface ValidationResult {\n  isValid: boolean;\n  conflictingPositions: Position[];\n}\n\nexport class SudokuValidationService {\n  validateMove(grid: SudokuGrid, position: Position, value: CellValue): ValidationResult {\n    if (value.isEmpty()) {\n      return { isValid: true, conflictingPositions: [] };\n    }\n\n    const conflictingPositions = this.findConflicts(grid, position, value);\n    \n    return {\n      isValid: conflictingPositions.length === 0,\n      conflictingPositions\n    };\n  }\n\n  private findConflicts(grid: SudokuGrid, position: Position, value: CellValue): Position[] {\n    const conflicts: Position[] = [];\n    \n    conflicts.push(...this.findRowConflicts(grid, position, value));\n    conflicts.push(...this.findColumnConflicts(grid, position, value));\n    conflicts.push(...this.findBoxConflicts(grid, position, value));\n    \n    return conflicts;\n  }\n\n  private findRowConflicts(grid: SudokuGrid, position: Position, value: CellValue): Position[] {\n    const conflicts: Position[] = [];\n    const row = grid.getRow(position.row);\n    \n    row.forEach(cell => {\n      if (!cell.position.equals(position) && \n          cell.value.equals(value) && \n          !cell.value.isEmpty()) {\n        conflicts.push(cell.position);\n      }\n    });\n    \n    return conflicts;\n  }\n\n  private findColumnConflicts(grid: SudokuGrid, position: Position, value: CellValue): Position[] {\n    const conflicts: Position[] = [];\n    const column = grid.getColumn(position.col);\n    \n    column.forEach(cell => {\n      if (!cell.position.equals(position) && \n          cell.value.equals(value) && \n          !cell.value.isEmpty()) {\n        conflicts.push(cell.position);\n      }\n    });\n    \n    return conflicts;\n  }\n\n  private findBoxConflicts(grid: SudokuGrid, position: Position, value: CellValue): Position[] {\n    const conflicts: Position[] = [];\n    const boxIndex = position.getBoxIndex();\n    const box = grid.getBox(boxIndex);\n    \n    box.forEach(cell => {\n      if (!cell.position.equals(position) && \n          cell.value.equals(value) && \n          !cell.value.isEmpty()) {\n        conflicts.push(cell.position);\n      }\n    });\n    \n    return conflicts;\n  }\n\n  isGridComplete(grid: SudokuGrid): boolean {\n    if (!grid.isFull()) {\n      return false;\n    }\n\n    return grid.getAllCells().every(cell => {\n      if (cell.isEmpty()) return false;\n      \n      const validation = this.validateMove(grid, cell.position, cell.value);\n      return validation.isValid;\n    });\n  }\n\n  getPossibleValues(grid: SudokuGrid, position: Position): CellValue[] {\n    const possibleValues: CellValue[] = [];\n    \n    for (let value = 1; value <= 9; value++) {\n      const cellValue = CellValue.from(value);\n      const validation = this.validateMove(grid, position, cellValue);\n      \n      if (validation.isValid) {\n        possibleValues.push(cellValue);\n      }\n    }\n    \n    return possibleValues;\n  }\n}","import { SudokuGrid } from '../aggregates/Grid';\nimport { Cell } from '../entities/Cell';\nimport { Position } from '../value-objects/Position';\nimport { CellValue } from '../value-objects/CellValue';\nimport { Difficulty } from '../entities/GameState';\nimport { SudokuValidationService } from './GridValidationService';\n\nexport interface GenerationOptions {\n  seed?: number;\n  useSymmetricRemoval?: boolean;\n}\n\nexport class SudokuGeneratorService {\n  private validationService: SudokuValidationService;\n  private random: () => number;\n\n  constructor(seed?: number) {\n    this.validationService = new SudokuValidationService();\n    \n    // 시드가 있으면 deterministic random 사용, 없으면 Math.random\n    if (seed !== undefined) {\n      this.random = this.createSeededRandom(seed);\n    } else {\n      this.random = Math.random;\n    }\n  }\n\n  generatePuzzle(difficulty: Difficulty, options: GenerationOptions = {}): SudokuGrid {\n    // 1. 완전한 해답 생성 (백트래킹으로 항상 성공)\n    const completeSolution = this.generateCompleteSolution();\n\n    // 2. 간단한 숫자 치환만으로 랜덤화\n    const randomizedSolution = this.substituteNumbers(completeSolution);\n\n    // 3. 난이도에 따라 셀 제거하여 퍼즐 생성\n    return this.removeCells(randomizedSolution, difficulty, options.useSymmetricRemoval);\n  }\n\n  private generateCompleteSolution(): SudokuGrid {\n    // 빈 그리드로 시작\n    const grid = new SudokuGrid();\n    \n    // 첫 번째 행을 1-9로 랜덤 배치 (성능 최적화)\n    const firstRow = this.shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    for (let col = 0; col < 9; col++) {\n      const position = new Position(0, col);\n      const value = CellValue.from(firstRow[col]);\n      const cell = new Cell(position, value, { isGiven: false });\n      \n      const cells = this.getGridCells(grid);\n      cells[0][col] = cell;\n      const newGrid = new SudokuGrid(cells);\n      \n      if (!this.validationService.validateMove(newGrid, position, value).isValid) {\n        throw new Error('Invalid first row generation');\n      }\n    }\n    \n    // 나머지 셀을 백트래킹으로 채움\n    const initialGrid = this.setFirstRow(grid, firstRow);\n    return this.solveWithBacktracking(initialGrid) || grid;\n  }\n\n  private solveWithBacktracking(grid: SudokuGrid): SudokuGrid | null {\n    const emptyCells = this.getEmptyCells(grid);\n    \n    if (emptyCells.length === 0) {\n      return grid; // 완성됨\n    }\n\n    const position = emptyCells[0];\n    const possibleValues = this.validationService.getPossibleValues(grid, position);\n    \n    // 랜덤 순서로 값 시도\n    const shuffledValues = this.shuffleArray(possibleValues);\n    \n    for (const value of shuffledValues) {\n      const newGrid = grid.setCell(position, value);\n      \n      if (this.validationService.validateMove(newGrid, position, value).isValid) {\n        const result = this.solveWithBacktracking(newGrid);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    \n    return null; // 백트래킹\n  }\n\n\n  private removeCells(grid: SudokuGrid, difficulty: Difficulty, _symmetric = false): SudokuGrid {\n    const cellsToRemove = this.getCellsToRemove(difficulty);\n    const positions = this.getAllPositions();\n    const shuffledPositions = this.shuffleArray(positions);\n\n    let currentGrid = grid;\n    let removedCount = 0;\n\n    for (const position of shuffledPositions) {\n      if (removedCount >= cellsToRemove) break;\n\n      const originalCell = currentGrid.getCell(position);\n      if (originalCell.isEmpty()) continue;\n\n      // 단순한 셀 제거 (유니크해 검증 없음)\n      currentGrid = currentGrid.setCell(position, CellValue.empty());\n      removedCount++;\n    }\n\n    return this.markGivenCells(currentGrid);\n  }\n\n  private getCellsToRemove(difficulty: Difficulty): number {\n    switch (difficulty) {\n      case Difficulty.EASY: return 38;     // 43개 주어진 숫자\n      case Difficulty.MEDIUM: return 44;   // 37개 주어진 숫자\n      case Difficulty.HARD: return 50;     // 31개 주어진 숫자\n      case Difficulty.EXPERT: return 57;   // 24개 주어진 숫자\n      default: return 44;\n    }\n  }\n\n\n  // 유틸리티 메서드들\n  private shuffleArray<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(this.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n\n\n  private createSeededRandom(seed: number): () => number {\n    let state = seed;\n    return () => {\n      state = (state * 1664525 + 1013904223) % 4294967296;\n      return state / 4294967296;\n    };\n  }\n\n  private getEmptyCells(grid: SudokuGrid): Position[] {\n    const emptyCells: Position[] = [];\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        const position = new Position(row, col);\n        if (grid.getCell(position).isEmpty()) {\n          emptyCells.push(position);\n        }\n      }\n    }\n    return emptyCells;\n  }\n\n  private getAllPositions(): Position[] {\n    const positions: Position[] = [];\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        positions.push(new Position(row, col));\n      }\n    }\n    return positions;\n  }\n\n  private getGridCells(grid: SudokuGrid): Cell[][] {\n    const cells: Cell[][] = [];\n    for (let row = 0; row < 9; row++) {\n      cells[row] = [];\n      for (let col = 0; col < 9; col++) {\n        cells[row][col] = grid.getCell(new Position(row, col));\n      }\n    }\n    return cells;\n  }\n\n  private setFirstRow(grid: SudokuGrid, values: number[]): SudokuGrid {\n    const cells = this.getGridCells(grid);\n    for (let col = 0; col < 9; col++) {\n      const position = new Position(0, col);\n      const value = CellValue.from(values[col]);\n      cells[0][col] = new Cell(position, value, { isGiven: false });\n    }\n    return new SudokuGrid(cells);\n  }\n\n  private markGivenCells(grid: SudokuGrid): SudokuGrid {\n    const cells = this.getGridCells(grid);\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        const cell = cells[row][col];\n        if (!cell.isEmpty()) {\n          cells[row][col] = new Cell(cell.position, cell.value, { isGiven: true });\n        }\n      }\n    }\n    return new SudokuGrid(cells);\n  }\n\n  private substituteNumbers(grid: SudokuGrid): SudokuGrid {\n    const substitution = this.generateNumberSubstitution();\n    const cells = this.getGridCells(grid);\n    \n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        const cell = cells[row][col];\n        if (!cell.isEmpty()) {\n          const newValue = CellValue.from(substitution[cell.value.value!]);\n          cells[row][col] = new Cell(cell.position, newValue, { isGiven: false });\n        }\n      }\n    }\n    \n    return new SudokuGrid(cells);\n  }\n\n  private generateNumberSubstitution(): Record<number, number> {\n    const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const shuffled = this.shuffleArray(numbers);\n    const substitution: Record<number, number> = {};\n    \n    for (let i = 0; i < 9; i++) {\n      substitution[numbers[i]] = shuffled[i];\n    }\n    \n    return substitution;\n  }\n\n\n}","export enum EffectType {\n  ROW_COMPLETION = 'ROW_COMPLETION',\n  COLUMN_COMPLETION = 'COLUMN_COMPLETION'\n}","export enum EffectAnimation {\n  LINEAR = 'LINEAR',     // 선형 이펙트 (기존 방식)\n  RADIAL = 'RADIAL'      // 중심에서 퍼지는 이펙트\n}","export enum EffectState {\n  PENDING = 'PENDING',\n  PLAYING = 'PLAYING',\n  COMPLETED = 'COMPLETED'\n}","import { Position } from '../../sudoku/value-objects/Position';\n\nimport { EffectType } from '../value-objects/EffectType';\nimport { EffectAnimation } from '../value-objects/EffectAnimation';\nimport { EffectState } from '../value-objects/EffectState';\n\nexport { EffectType, EffectAnimation, EffectState };\n\nexport interface CellEffectState {\n  position: Position;\n  startTime: number;\n  stepIndex: number; // 0-9 for 10 steps\n  isActive: boolean;\n  isCompleted: boolean;\n}\n\nexport abstract class LineCompletionEffect {\n  protected static readonly EFFECT_STEPS = 15; // animation steps per cell\n  protected static readonly STEP_INTERVAL = 35; // ms per step\n\n  constructor(\n    public readonly id: string,\n    public readonly type: EffectType,\n    public readonly animation: EffectAnimation,\n    public readonly lineIndex: number,\n    public readonly cellPositions: Position[],\n    public readonly state: EffectState,\n    public readonly startTime: number,\n    public readonly cellEffects: CellEffectState[] = [],\n    public readonly completionPosition?: Position // 완성된 셀의 위치\n  ) {}\n\n  abstract start(): LineCompletionEffect;\n  protected abstract calculateCellStartTime(cellIndex: number, baseStartTime: number): number;\n\n  protected createCellEffects(startTime: number): CellEffectState[] {\n    return this.cellPositions.map((position, index) => ({\n      position,\n      startTime: this.calculateCellStartTime(index, startTime),\n      stepIndex: 0,\n      isActive: false,\n      isCompleted: false\n    }));\n  }\n\n  updateProgress(currentTime: number): LineCompletionEffect {\n    if (this.state !== EffectState.PLAYING) {\n      return this;\n    }\n\n    const updatedCellEffects = this.cellEffects.map(cellEffect => {\n      if (cellEffect.isCompleted) {\n        return cellEffect;\n      }\n\n      const timeSinceStart = currentTime - cellEffect.startTime;\n\n      // Cell hasn't started yet\n      if (timeSinceStart < 0) {\n        return cellEffect;\n      }\n\n      // Cell is now active\n      if (!cellEffect.isActive) {\n        return {\n          ...cellEffect,\n          isActive: true,\n          stepIndex: 0\n        };\n      }\n\n      // Update step based on time\n      const stepIndex = Math.floor(timeSinceStart / LineCompletionEffect.STEP_INTERVAL);\n\n      if (stepIndex >= LineCompletionEffect.EFFECT_STEPS) {\n        return {\n          ...cellEffect,\n          stepIndex: LineCompletionEffect.EFFECT_STEPS - 1,\n          isCompleted: true\n        };\n      }\n\n      return {\n        ...cellEffect,\n        stepIndex: Math.max(0, stepIndex)\n      };\n    });\n\n    // Check if all cells are completed\n    const allCompleted = updatedCellEffects.every(effect => effect.isCompleted);\n    const newState = allCompleted ? EffectState.COMPLETED : EffectState.PLAYING;\n\n    // Create new instance with same concrete type\n    const constructor = this.constructor as any;\n    return new constructor(\n      this.id,\n      this.type,\n      this.animation,\n      this.lineIndex,\n      this.cellPositions,\n      newState,\n      this.startTime,\n      updatedCellEffects,\n      this.completionPosition\n    );\n  }\n\n  getActiveCellEffects(): CellEffectState[] {\n    return this.cellEffects.filter(effect => effect.isActive && !effect.isCompleted);\n  }\n\n  getCellEffectProgress(position: Position): { scale: number; opacity: number } | null {\n    const cellEffect = this.cellEffects.find(effect =>\n      effect.position.equals(position)\n    );\n\n    if (!cellEffect || !cellEffect.isActive || cellEffect.isCompleted) {\n      return null;\n    }\n\n    // Calculate progress (0-1) based on step index\n    const progress = cellEffect.stepIndex / (LineCompletionEffect.EFFECT_STEPS - 1);\n\n    // Scale from 100% to 150%\n    const scale = 1.0 + (progress * 0.5);\n\n    // Opacity from 100% to 0%\n    const opacity = 1.0 - progress;\n\n    return { scale, opacity };\n  }\n\n  isCompleted(): boolean {\n    return this.state === EffectState.COMPLETED;\n  }\n\n  isPlaying(): boolean {\n    return this.state === EffectState.PLAYING;\n  }\n\n  // Legacy method for backward compatibility\n  getCurrentlyAnimatingPositions(): Position[] {\n    return this.getActiveCellEffects().map(effect => effect.position);\n  }\n}","import { Position } from '../../sudoku/value-objects/Position';\nimport { LineCompletionEffect, EffectType, EffectAnimation, EffectState } from './LineCompletionEffect';\n\nexport class LinearEffect extends LineCompletionEffect {\n  private static readonly CELL_DELAY = 35; // ms delay between cells\n\n  static createRowEffect(id: string, rowIndex: number): LinearEffect {\n    const cellPositions: Position[] = [];\n    for (let col = 0; col < 9; col++) {\n      cellPositions.push(new Position(rowIndex, col));\n    }\n\n    return new LinearEffect(\n      id,\n      EffectType.ROW_COMPLETION,\n      EffectAnimation.LINEAR,\n      rowIndex,\n      cellPositions,\n      EffectState.PENDING,\n      Date.now(),\n      []\n    );\n  }\n\n  static createColumnEffect(id: string, colIndex: number): LinearEffect {\n    const cellPositions: Position[] = [];\n    for (let row = 0; row < 9; row++) {\n      cellPositions.push(new Position(row, colIndex));\n    }\n\n    return new LinearEffect(\n      id,\n      EffectType.COLUMN_COMPLETION,\n      EffectAnimation.LINEAR,\n      colIndex,\n      cellPositions,\n      EffectState.PENDING,\n      Date.now(),\n      []\n    );\n  }\n\n  start(): LinearEffect {\n    const startTime = Date.now();\n    const cellEffects = this.createCellEffects(startTime);\n\n    return new LinearEffect(\n      this.id,\n      this.type,\n      this.animation,\n      this.lineIndex,\n      this.cellPositions,\n      EffectState.PLAYING,\n      startTime,\n      cellEffects,\n      this.completionPosition\n    );\n  }\n\n  protected calculateCellStartTime(cellIndex: number, baseStartTime: number): number {\n    // Linear effect: sequential from left to right or top to bottom\n    return baseStartTime + (cellIndex * LinearEffect.CELL_DELAY);\n  }\n}","import { Position } from '../../sudoku/value-objects/Position';\nimport { LineCompletionEffect, EffectType, EffectAnimation, EffectState } from './LineCompletionEffect';\n\nexport class RadialEffect extends LineCompletionEffect {\n  private static readonly CELL_DELAY = 35; // ms delay between cells\n\n  static createRowEffect(id: string, rowIndex: number, completionPosition: Position): RadialEffect {\n    const cellPositions: Position[] = [];\n    for (let col = 0; col < 9; col++) {\n      cellPositions.push(new Position(rowIndex, col));\n    }\n\n    return new RadialEffect(\n      id,\n      EffectType.ROW_COMPLETION,\n      EffectAnimation.RADIAL,\n      rowIndex,\n      cellPositions,\n      EffectState.PENDING,\n      Date.now(),\n      [],\n      completionPosition\n    );\n  }\n\n  static createColumnEffect(id: string, colIndex: number, completionPosition: Position): RadialEffect {\n    const cellPositions: Position[] = [];\n    for (let row = 0; row < 9; row++) {\n      cellPositions.push(new Position(row, colIndex));\n    }\n\n    return new RadialEffect(\n      id,\n      EffectType.COLUMN_COMPLETION,\n      EffectAnimation.RADIAL,\n      colIndex,\n      cellPositions,\n      EffectState.PENDING,\n      Date.now(),\n      [],\n      completionPosition\n    );\n  }\n\n  start(): RadialEffect {\n    const startTime = Date.now();\n    const cellEffects = this.createCellEffects(startTime);\n\n    return new RadialEffect(\n      this.id,\n      this.type,\n      this.animation,\n      this.lineIndex,\n      this.cellPositions,\n      EffectState.PLAYING,\n      startTime,\n      cellEffects,\n      this.completionPosition\n    );\n  }\n\n  protected calculateCellStartTime(cellIndex: number, baseStartTime: number): number {\n    if (!this.completionPosition) {\n      // Fallback to linear if no completion position\n      return baseStartTime + (cellIndex * RadialEffect.CELL_DELAY);\n    }\n\n    const cellPosition = this.cellPositions[cellIndex];\n    let distance: number;\n\n    if (this.type === EffectType.ROW_COMPLETION) {\n      // For row completion, calculate distance from completion column\n      distance = Math.abs(cellPosition.col - this.completionPosition.col);\n    } else {\n      // For column completion, calculate distance from completion row\n      distance = Math.abs(cellPosition.row - this.completionPosition.row);\n    }\n\n    // Cells at the same distance start simultaneously\n    // Add small random offset to prevent all cells starting at exact same time\n    const randomOffset = Math.random() * 5; // 0-5ms random offset\n    return baseStartTime + (distance * RadialEffect.CELL_DELAY) + randomOffset;\n  }\n\n  // Get cells grouped by their distance from completion position\n  getCellsByDistance(): Map<number, Position[]> {\n    if (!this.completionPosition) {\n      return new Map();\n    }\n\n    const cellsByDistance = new Map<number, Position[]>();\n\n    this.cellPositions.forEach(position => {\n      let distance: number;\n\n      if (this.type === EffectType.ROW_COMPLETION) {\n        distance = Math.abs(position.col - this.completionPosition!.col);\n      } else {\n        distance = Math.abs(position.row - this.completionPosition!.row);\n      }\n\n      if (!cellsByDistance.has(distance)) {\n        cellsByDistance.set(distance, []);\n      }\n      cellsByDistance.get(distance)!.push(position);\n    });\n\n    return cellsByDistance;\n  }\n}","export class EffectSequenceId {\n  constructor(private readonly value: string) {\n    if (!value || value.trim().length === 0) {\n      throw new Error('EffectSequenceId cannot be empty');\n    }\n  }\n\n  static generate(): EffectSequenceId {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substr(2, 9);\n    return new EffectSequenceId(`sequence_${timestamp}_${random}`);\n  }\n\n  static fromString(value: string): EffectSequenceId {\n    return new EffectSequenceId(value);\n  }\n\n  toString(): string {\n    return this.value;\n  }\n\n  equals(other: EffectSequenceId): boolean {\n    return this.value === other.value;\n  }\n}","export enum SequenceState {\n  PENDING = 'PENDING',     // 시퀀스가 시작되지 않음\n  RUNNING = 'RUNNING',     // 시퀀스가 실행 중\n  PAUSED = 'PAUSED',       // 시퀀스가 일시 정지됨\n  COMPLETED = 'COMPLETED', // 모든 이펙트가 완료됨\n  CANCELLED = 'CANCELLED'  // 시퀀스가 취소됨\n}","import { EffectSequenceId } from '../value-objects/EffectSequenceId';\n\nexport interface DomainEvent {\n  readonly eventId: string;\n  readonly aggregateId: string;\n  readonly eventType: string;\n  readonly occurredAt: Date;\n  readonly version: number;\n}\n\nexport abstract class EffectDomainEvent implements DomainEvent {\n  public readonly eventId: string;\n  public readonly occurredAt: Date;\n  public readonly version: number = 1;\n\n  constructor(\n    public readonly aggregateId: string,\n    public readonly eventType: string\n  ) {\n    this.eventId = `${eventType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    this.occurredAt = new Date();\n  }\n}\n\n// 시퀀스 생명주기 이벤트들\nexport class EffectSequenceStarted extends EffectDomainEvent {\n  constructor(\n    public readonly sequenceId: EffectSequenceId,\n    public readonly effectCount: number\n  ) {\n    super(sequenceId.toString(), 'EffectSequenceStarted');\n  }\n}\n\nexport class EffectSequenceCompleted extends EffectDomainEvent {\n  constructor(\n    public readonly sequenceId: EffectSequenceId,\n    public readonly duration: number\n  ) {\n    super(sequenceId.toString(), 'EffectSequenceCompleted');\n  }\n}\n\nexport class EffectSequenceCancelled extends EffectDomainEvent {\n  constructor(\n    public readonly sequenceId: EffectSequenceId,\n    public readonly reason: string\n  ) {\n    super(sequenceId.toString(), 'EffectSequenceCancelled');\n  }\n}\n\nexport class EffectSequencePaused extends EffectDomainEvent {\n  constructor(\n    public readonly sequenceId: EffectSequenceId\n  ) {\n    super(sequenceId.toString(), 'EffectSequencePaused');\n  }\n}\n\nexport class EffectSequenceResumed extends EffectDomainEvent {\n  constructor(\n    public readonly sequenceId: EffectSequenceId\n  ) {\n    super(sequenceId.toString(), 'EffectSequenceResumed');\n  }\n}\n\n// 개별 이펙트 이벤트들\nexport class LineCompletionEffectStarted extends EffectDomainEvent {\n  constructor(\n    public readonly effectId: string,\n    public readonly sequenceId: EffectSequenceId,\n    public readonly effectType: string\n  ) {\n    super(effectId, 'LineCompletionEffectStarted');\n  }\n}\n\nexport class LineCompletionEffectCompleted extends EffectDomainEvent {\n  constructor(\n    public readonly effectId: string,\n    public readonly sequenceId: EffectSequenceId,\n    public readonly duration: number\n  ) {\n    super(effectId, 'LineCompletionEffectCompleted');\n  }\n}\n\n// 이펙트 진행 상황 이벤트\nexport class EffectProgressUpdated extends EffectDomainEvent {\n  constructor(\n    public readonly sequenceId: EffectSequenceId,\n    public readonly progress: number,\n    public readonly activeEffectCount: number\n  ) {\n    super(sequenceId.toString(), 'EffectProgressUpdated');\n  }\n}","import { EffectSequenceId } from '../value-objects/EffectSequenceId';\nimport { SequenceState } from '../value-objects/SequenceState';\nimport { LineCompletionEffect } from '../entities/LineCompletionEffect';\nimport {\n  EffectSequenceStarted,\n  EffectDomainEvent\n} from '../events/EffectDomainEvent';\n\nexport interface EffectSequenceOptions {\n  readonly allowConcurrent?: boolean;  // 동시 실행 허용 여부\n  readonly autoStart?: boolean;        // 자동 시작 여부\n  readonly repeatCount?: number;       // 반복 횟수 (0 = 무한, 1 = 기본값)\n  readonly delayBetweenEffects?: number; // 이펙트 간 지연 시간 (ms)\n}\n\nexport class EffectSequence {\n  private readonly effects: LineCompletionEffect[] = [];\n  private currentEffectIndex: number = 0;\n  private startTime?: number;\n  private completedCount: number = 0;\n  private readonly domainEvents: EffectDomainEvent[] = [];\n\n  constructor(\n    public readonly id: EffectSequenceId,\n    public readonly state: SequenceState = SequenceState.PENDING,\n    public readonly options: EffectSequenceOptions = {},\n    effects: LineCompletionEffect[] = [],\n    startTime?: number,\n    currentEffectIndex: number = 0,\n    completedCount: number = 0\n  ) {\n    this.effects = [...effects];\n    this.startTime = startTime;\n    this.currentEffectIndex = currentEffectIndex;\n    this.completedCount = completedCount;\n  }\n\n  static create(\n    effects: LineCompletionEffect[],\n    options: EffectSequenceOptions = {}\n  ): EffectSequence {\n    if (effects.length === 0) {\n      throw new Error('EffectSequence must contain at least one effect');\n    }\n\n    const id = EffectSequenceId.generate();\n    const defaultOptions: EffectSequenceOptions = {\n      allowConcurrent: false,\n      autoStart: true,\n      repeatCount: 1,\n      delayBetweenEffects: 0,\n      ...options\n    };\n\n    return new EffectSequence(\n      id,\n      SequenceState.PENDING,\n      defaultOptions,\n      effects\n    );\n  }\n\n  addEffect(effect: LineCompletionEffect): EffectSequence {\n    if (this.state === SequenceState.RUNNING) {\n      throw new Error('Cannot add effects to a running sequence');\n    }\n\n    const newEffects = [...this.effects, effect];\n    return new EffectSequence(\n      this.id,\n      this.state,\n      this.options,\n      newEffects,\n      this.startTime,\n      this.currentEffectIndex,\n      this.completedCount\n    );\n  }\n\n  start(): EffectSequence {\n    if (this.state === SequenceState.RUNNING) {\n      return this;\n    }\n\n    if (this.effects.length === 0) {\n      throw new Error('Cannot start sequence with no effects');\n    }\n\n    const startTime = Date.now();\n    const startedSequence = new EffectSequence(\n      this.id,\n      SequenceState.RUNNING,\n      this.options,\n      this.effects.map((effect, index) =>\n        index === 0 ? effect.start() : effect\n      ),\n      startTime,\n      0,\n      this.completedCount\n    );\n\n    // 시작 이벤트 발행\n    startedSequence.addDomainEvent(\n      new EffectSequenceStarted(this.id, this.effects.length)\n    );\n\n    return startedSequence;\n  }\n\n  pause(): EffectSequence {\n    if (this.state !== SequenceState.RUNNING) {\n      return this;\n    }\n\n    return new EffectSequence(\n      this.id,\n      SequenceState.PAUSED,\n      this.options,\n      this.effects,\n      this.startTime,\n      this.currentEffectIndex,\n      this.completedCount\n    );\n  }\n\n  resume(): EffectSequence {\n    if (this.state !== SequenceState.PAUSED) {\n      return this;\n    }\n\n    return new EffectSequence(\n      this.id,\n      SequenceState.RUNNING,\n      this.options,\n      this.effects,\n      this.startTime,\n      this.currentEffectIndex,\n      this.completedCount\n    );\n  }\n\n  cancel(): EffectSequence {\n    if (this.state === SequenceState.COMPLETED || this.state === SequenceState.CANCELLED) {\n      return this;\n    }\n\n    return new EffectSequence(\n      this.id,\n      SequenceState.CANCELLED,\n      this.options,\n      this.effects,\n      this.startTime,\n      this.currentEffectIndex,\n      this.completedCount\n    );\n  }\n\n  update(currentTime: number): EffectSequence {\n    if (this.state !== SequenceState.RUNNING) {\n      return this;\n    }\n\n    // 동시 실행 모드\n    if (this.options.allowConcurrent) {\n      return this.updateConcurrentEffects(currentTime);\n    }\n\n    // 순차 실행 모드\n    return this.updateSequentialEffects(currentTime);\n  }\n\n  private updateConcurrentEffects(currentTime: number): EffectSequence {\n    const updatedEffects = this.effects.map(effect =>\n      effect.isPlaying() ? effect.updateProgress(currentTime) : effect\n    );\n\n    const allCompleted = updatedEffects.every(effect => effect.isCompleted());\n\n    if (allCompleted) {\n      return this.handleSequenceCompletion(updatedEffects);\n    }\n\n    return new EffectSequence(\n      this.id,\n      this.state,\n      this.options,\n      updatedEffects,\n      this.startTime,\n      this.currentEffectIndex,\n      this.completedCount\n    );\n  }\n\n  private updateSequentialEffects(currentTime: number): EffectSequence {\n    if (this.currentEffectIndex >= this.effects.length) {\n      return this.handleSequenceCompletion(this.effects);\n    }\n\n    const currentEffect = this.effects[this.currentEffectIndex];\n    const updatedCurrentEffect = currentEffect.updateProgress(currentTime);\n\n    const updatedEffects = this.effects.map((effect, index) =>\n      index === this.currentEffectIndex ? updatedCurrentEffect : effect\n    );\n\n    // 현재 이펙트가 완료되면 다음 이펙트로 진행\n    if (updatedCurrentEffect.isCompleted()) {\n      const nextIndex = this.currentEffectIndex + 1;\n\n      if (nextIndex < this.effects.length) {\n        // 다음 이펙트 시작 (딜레이 고려)\n        const shouldStartNext = this.shouldStartNextEffect(currentTime);\n\n        if (shouldStartNext) {\n          const nextEffect = this.effects[nextIndex].start();\n          updatedEffects[nextIndex] = nextEffect;\n\n          return new EffectSequence(\n            this.id,\n            this.state,\n            this.options,\n            updatedEffects,\n            this.startTime,\n            nextIndex,\n            this.completedCount\n          );\n        }\n      } else {\n        // 모든 이펙트 완료\n        return this.handleSequenceCompletion(updatedEffects);\n      }\n    }\n\n    return new EffectSequence(\n      this.id,\n      this.state,\n      this.options,\n      updatedEffects,\n      this.startTime,\n      this.currentEffectIndex,\n      this.completedCount\n    );\n  }\n\n  private shouldStartNextEffect(_currentTime: number): boolean {\n    if (!this.options.delayBetweenEffects || this.options.delayBetweenEffects <= 0) {\n      return true;\n    }\n\n    const currentEffect = this.effects[this.currentEffectIndex];\n    if (!currentEffect.isCompleted()) {\n      return false;\n    }\n\n    // 딜레이 시간 계산 로직 구현\n    // 현재는 단순화하여 즉시 시작\n    return true;\n  }\n\n  private handleSequenceCompletion(effects: LineCompletionEffect[]): EffectSequence {\n    const newCompletedCount = this.completedCount + 1;\n    const repeatCount = this.options.repeatCount || 1;\n\n    // 반복 실행 체크\n    if (repeatCount === 0 || newCompletedCount < repeatCount) {\n      // 시퀀스 재시작\n      const resetEffects = effects.map(effect =>\n        // 이펙트를 초기 상태로 리셋하는 로직 필요\n        effect\n      );\n\n      return new EffectSequence(\n        this.id,\n        SequenceState.PENDING,\n        this.options,\n        resetEffects,\n        undefined,\n        0,\n        newCompletedCount\n      );\n    }\n\n    // 완전 완료\n    return new EffectSequence(\n      this.id,\n      SequenceState.COMPLETED,\n      this.options,\n      effects,\n      this.startTime,\n      this.currentEffectIndex,\n      newCompletedCount\n    );\n  }\n\n  // 읽기 전용 접근자\n  getEffects(): readonly LineCompletionEffect[] {\n    return this.effects;\n  }\n\n  getCurrentEffect(): LineCompletionEffect | undefined {\n    return this.effects[this.currentEffectIndex];\n  }\n\n  getActiveEffects(): LineCompletionEffect[] {\n    if (this.options.allowConcurrent) {\n      return this.effects.filter(effect => effect.isPlaying());\n    }\n\n    const current = this.getCurrentEffect();\n    return current && current.isPlaying() ? [current] : [];\n  }\n\n  getProgress(): number {\n    if (this.effects.length === 0) return 1;\n\n    if (this.options.allowConcurrent) {\n      const completedEffects = this.effects.filter(effect => effect.isCompleted()).length;\n      return completedEffects / this.effects.length;\n    }\n\n    return this.currentEffectIndex / this.effects.length;\n  }\n\n  isRunning(): boolean {\n    return this.state === SequenceState.RUNNING;\n  }\n\n  isCompleted(): boolean {\n    return this.state === SequenceState.COMPLETED;\n  }\n\n  isCancelled(): boolean {\n    return this.state === SequenceState.CANCELLED;\n  }\n\n  isPaused(): boolean {\n    return this.state === SequenceState.PAUSED;\n  }\n\n  // 도메인 이벤트 관리\n  getDomainEvents(): EffectDomainEvent[] {\n    return [...this.domainEvents];\n  }\n\n  clearDomainEvents(): EffectSequence {\n    return new EffectSequence(\n      this.id,\n      this.state,\n      this.options,\n      this.effects,\n      this.startTime,\n      this.currentEffectIndex,\n      this.completedCount\n    );\n  }\n\n  private addDomainEvent(event: EffectDomainEvent): void {\n    this.domainEvents.push(event);\n  }\n}","import { Position } from '../../sudoku/value-objects/Position';\nimport { LineCompletionEffect, EffectAnimation } from '../entities/LineCompletionEffect';\nimport { LinearEffect } from '../entities/LinearEffect';\nimport { RadialEffect } from '../entities/RadialEffect';\nimport { EffectSequence, EffectSequenceOptions } from '../aggregates/EffectSequence';\n\nexport class EffectFactory {\n  private static effectIdCounter = 0;\n\n  private static generateId(): string {\n    return `effect_${Date.now()}_${++this.effectIdCounter}`;\n  }\n\n  static createRowEffect(\n    rowIndex: number,\n    animation: EffectAnimation = EffectAnimation.LINEAR,\n    completionPosition?: Position\n  ): LineCompletionEffect {\n    const id = this.generateId();\n\n    switch (animation) {\n      case EffectAnimation.LINEAR:\n        return LinearEffect.createRowEffect(id, rowIndex);\n\n      case EffectAnimation.RADIAL:\n        if (!completionPosition) {\n          throw new Error('RadialEffect requires completion position');\n        }\n        return RadialEffect.createRowEffect(id, rowIndex, completionPosition);\n\n      default:\n        throw new Error(`Unsupported animation type: ${animation}`);\n    }\n  }\n\n  static createColumnEffect(\n    colIndex: number,\n    animation: EffectAnimation = EffectAnimation.LINEAR,\n    completionPosition?: Position\n  ): LineCompletionEffect {\n    const id = this.generateId();\n\n    switch (animation) {\n      case EffectAnimation.LINEAR:\n        return LinearEffect.createColumnEffect(id, colIndex);\n\n      case EffectAnimation.RADIAL:\n        if (!completionPosition) {\n          throw new Error('RadialEffect requires completion position');\n        }\n        return RadialEffect.createColumnEffect(id, colIndex, completionPosition);\n\n      default:\n        throw new Error(`Unsupported animation type: ${animation}`);\n    }\n  }\n\n  // 시퀀스 생성 메서드들\n  static createSimpleSequence(\n    effects: LineCompletionEffect[],\n    options?: EffectSequenceOptions\n  ): EffectSequence {\n    return EffectSequence.create(effects, options);\n  }\n\n  static createConcurrentSequence(\n    effects: LineCompletionEffect[],\n    options?: Omit<EffectSequenceOptions, 'allowConcurrent'>\n  ): EffectSequence {\n    return EffectSequence.create(effects, {\n      ...options,\n      allowConcurrent: true\n    });\n  }\n\n  static createDelayedSequence(\n    effects: LineCompletionEffect[],\n    delayBetweenEffects: number,\n    options?: Omit<EffectSequenceOptions, 'delayBetweenEffects'>\n  ): EffectSequence {\n    return EffectSequence.create(effects, {\n      ...options,\n      delayBetweenEffects\n    });\n  }\n\n  static createRepeatingSequence(\n    effects: LineCompletionEffect[],\n    repeatCount: number,\n    options?: Omit<EffectSequenceOptions, 'repeatCount'>\n  ): EffectSequence {\n    return EffectSequence.create(effects, {\n      ...options,\n      repeatCount\n    });\n  }\n\n  // 복합 이펙트 생성 헬퍼 메서드들\n  static createMultiLineCompletionSequence(\n    completedLines: Array<{ type: 'row' | 'column', index: number, position?: Position }>,\n    animation: EffectAnimation = EffectAnimation.RADIAL,\n    options?: EffectSequenceOptions\n  ): EffectSequence {\n    const effects = completedLines.map(line => {\n      if (line.type === 'row') {\n        return this.createRowEffect(line.index, animation, line.position);\n      } else {\n        return this.createColumnEffect(line.index, animation, line.position);\n      }\n    });\n\n    return this.createSimpleSequence(effects, {\n      allowConcurrent: true,\n      delayBetweenEffects: 100, // 100ms 간격\n      ...options\n    });\n  }\n\n  static createCascadingEffectSequence(\n    completedLines: Array<{ type: 'row' | 'column', index: number, position?: Position }>,\n    animation: EffectAnimation = EffectAnimation.RADIAL,\n    cascadeDelay: number = 200\n  ): EffectSequence {\n    const effects = completedLines.map(line => {\n      if (line.type === 'row') {\n        return this.createRowEffect(line.index, animation, line.position);\n      } else {\n        return this.createColumnEffect(line.index, animation, line.position);\n      }\n    });\n\n    return this.createDelayedSequence(effects, cascadeDelay, {\n      allowConcurrent: false\n    });\n  }\n\n  static createLineCompletionSequence(\n    lineType: 'row' | 'column',\n    lineIndex: number,\n    completionPosition: Position,\n    animation?: EffectAnimation,\n    options?: EffectSequenceOptions\n  ): EffectSequence {\n    const effectAnimation = animation || EffectAnimation.RADIAL;\n\n    const effect = lineType === 'row'\n      ? this.createRowEffect(lineIndex, effectAnimation, completionPosition)\n      : this.createColumnEffect(lineIndex, effectAnimation, completionPosition);\n\n    return this.createSimpleSequence([effect], options);\n  }\n}","import { SudokuGrid } from '../aggregates/Grid';\nimport { Position } from '../value-objects/Position';\nimport { LineCompletionEffect, EffectAnimation } from '../../effects/entities/LineCompletionEffect';\nimport { EffectFactory } from '../../effects/services/EffectFactory';\n\nexport interface LineCompletionEvent {\n  type: 'ROW_COMPLETED' | 'COLUMN_COMPLETED';\n  lineIndex: number;\n  positions: Position[];\n  completionPosition?: Position; // 완성을 트리거한 셀의 위치\n}\n\nexport class LineCompletionDetectionService {\n  detectCompletions(grid: SudokuGrid, lastMovePosition?: Position): LineCompletionEvent[] {\n    const completions: LineCompletionEvent[] = [];\n\n    if (lastMovePosition) {\n      // Check row completion for the last move\n      if (this.isRowComplete(grid, lastMovePosition.row)) {\n        completions.push({\n          type: 'ROW_COMPLETED',\n          lineIndex: lastMovePosition.row,\n          positions: this.getRowPositions(lastMovePosition.row),\n          completionPosition: lastMovePosition\n        });\n      }\n\n      // Check column completion for the last move\n      if (this.isColumnComplete(grid, lastMovePosition.col)) {\n        completions.push({\n          type: 'COLUMN_COMPLETED',\n          lineIndex: lastMovePosition.col,\n          positions: this.getColumnPositions(lastMovePosition.col),\n          completionPosition: lastMovePosition\n        });\n      }\n    } else {\n      // Check all rows and columns\n      for (let i = 0; i < 9; i++) {\n        if (this.isRowComplete(grid, i)) {\n          completions.push({\n            type: 'ROW_COMPLETED',\n            lineIndex: i,\n            positions: this.getRowPositions(i)\n          });\n        }\n\n        if (this.isColumnComplete(grid, i)) {\n          completions.push({\n            type: 'COLUMN_COMPLETED',\n            lineIndex: i,\n            positions: this.getColumnPositions(i)\n          });\n        }\n      }\n    }\n\n    return completions;\n  }\n\n  createEffectsFromCompletions(\n    completions: LineCompletionEvent[],\n    animation: EffectAnimation = EffectAnimation.LINEAR\n  ): LineCompletionEffect[] {\n    return completions.map(completion => {\n      if (completion.type === 'ROW_COMPLETED') {\n        return EffectFactory.createRowEffect(\n          completion.lineIndex,\n          animation,\n          completion.completionPosition\n        );\n      } else {\n        return EffectFactory.createColumnEffect(\n          completion.lineIndex,\n          animation,\n          completion.completionPosition\n        );\n      }\n    });\n  }\n\n  private isRowComplete(grid: SudokuGrid, rowIndex: number): boolean {\n    const row = grid.getRow(rowIndex);\n\n    // Check if all cells are filled\n    if (!row.every(cell => !cell.isEmpty())) {\n      return false;\n    }\n\n    // Check if all numbers 1-9 are present (no duplicates)\n    const values = new Set(row.map(cell => cell.value.value));\n    return values.size === 9;\n  }\n\n  private isColumnComplete(grid: SudokuGrid, colIndex: number): boolean {\n    const column = grid.getColumn(colIndex);\n\n    // Check if all cells are filled\n    if (!column.every(cell => !cell.isEmpty())) {\n      return false;\n    }\n\n    // Check if all numbers 1-9 are present (no duplicates)\n    const values = new Set(column.map(cell => cell.value.value));\n    return values.size === 9;\n  }\n\n  private getRowPositions(rowIndex: number): Position[] {\n    const positions: Position[] = [];\n    for (let col = 0; col < 9; col++) {\n      positions.push(new Position(rowIndex, col));\n    }\n    return positions;\n  }\n\n  private getColumnPositions(colIndex: number): Position[] {\n    const positions: Position[] = [];\n    for (let row = 0; row < 9; row++) {\n      positions.push(new Position(row, colIndex));\n    }\n    return positions;\n  }\n}","/**\n * 도메인 이벤트 기본 인터페이스\n *\n * 도메인 내에서 발생하는 중요한 비즈니스 이벤트를 표현합니다.\n */\n\nexport interface DomainEvent {\n  readonly eventId: string;\n  readonly eventType: string;\n  readonly aggregateId: string;\n  readonly aggregateType: string;\n  readonly occurredOn: Date;\n  readonly version: number;\n  readonly data: Record<string, any>;\n}\n\n/**\n * 도메인 이벤트 기본 구현\n */\nexport abstract class BaseDomainEvent implements DomainEvent {\n  public readonly eventId: string;\n  public readonly occurredOn: Date;\n  public readonly version: number = 1;\n\n  constructor(\n    public readonly eventType: string,\n    public readonly aggregateId: string,\n    public readonly aggregateType: string,\n    public readonly data: Record<string, any> = {}\n  ) {\n    this.eventId = this.generateEventId();\n    this.occurredOn = new Date();\n  }\n\n  private generateEventId(): string {\n    return `${this.eventType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n/**\n * 도메인 이벤트 발행자 인터페이스\n */\nexport interface DomainEventPublisher {\n  /**\n   * 이벤트 발행\n   */\n  publish(event: DomainEvent): Promise<void>;\n\n  /**\n   * 다중 이벤트 발행\n   */\n  publishAll(events: DomainEvent[]): Promise<void>;\n\n  /**\n   * 이벤트 핸들러 등록\n   */\n  subscribe<T extends DomainEvent>(\n    eventType: string,\n    handler: DomainEventHandler<T>\n  ): void;\n\n  /**\n   * 이벤트 핸들러 제거\n   */\n  unsubscribe<T extends DomainEvent>(\n    eventType: string,\n    handler: DomainEventHandler<T>\n  ): void;\n}\n\n/**\n * 도메인 이벤트 핸들러 인터페이스\n */\nexport interface DomainEventHandler<T extends DomainEvent> {\n  handle(event: T): Promise<void>;\n}\n\n/**\n * 이벤트 저장소 인터페이스\n */\nexport interface EventStore {\n  /**\n   * 이벤트 저장\n   */\n  saveEvent(event: DomainEvent): Promise<void>;\n\n  /**\n   * 다중 이벤트 저장\n   */\n  saveEvents(events: DomainEvent[]): Promise<void>;\n\n  /**\n   * 애그리거트별 이벤트 조회\n   */\n  getEvents(aggregateId: string, fromVersion?: number): Promise<DomainEvent[]>;\n\n  /**\n   * 이벤트 타입별 조회\n   */\n  getEventsByType(eventType: string, limit?: number): Promise<DomainEvent[]>;\n\n  /**\n   * 날짜 범위별 이벤트 조회\n   */\n  getEventsByDateRange(startDate: Date, endDate: Date): Promise<DomainEvent[]>;\n}\n\n/**\n * 애그리거트 루트 인터페이스\n */\nexport interface AggregateRoot {\n  /**\n   * 도메인 이벤트 목록 조회\n   */\n  getDomainEvents(): DomainEvent[];\n\n  /**\n   * 도메인 이벤트 클리어\n   */\n  clearDomainEvents(): void;\n\n  /**\n   * 도메인 이벤트 추가\n   */\n  addDomainEvent(event: DomainEvent): void;\n}","import { BaseDomainEvent } from '../../common/events/DomainEvent.js';\nimport { Position } from '../value-objects/Position.js';\nimport { CellValue } from '../value-objects/CellValue.js';\nimport { Difficulty } from '../entities/GameState.js';\n\n/**\n * 스도쿠 도메인 이벤트들\n */\n\n/**\n * 게임 시작 이벤트\n */\nexport class GameStarted extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    difficulty: Difficulty,\n    metadata: {\n      gridSize: number;\n      clueCount: number;\n    }\n  ) {\n    super(\n      'GameStarted',\n      gameId,\n      'SudokuGame',\n      {\n        difficulty,\n        ...metadata\n      }\n    );\n  }\n}\n\n/**\n * 게임 생성 이벤트\n */\nexport class GameCreated extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    difficulty: Difficulty,\n    seed?: number\n  ) {\n    super(\n      'GameCreated',\n      gameId,\n      'SudokuGame',\n      {\n        difficulty,\n        seed,\n        gridSize: 9\n      }\n    );\n  }\n}\n\n/**\n * 수 입력 이벤트\n */\nexport class MoveAttempted extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    position: Position,\n    value: CellValue,\n    isValid: boolean,\n    conflictingPositions: Position[] = []\n  ) {\n    super(\n      'MoveAttempted',\n      gameId,\n      'SudokuGame',\n      {\n        position: { row: position.row, col: position.col },\n        value: value.value,\n        isValid,\n        conflictingPositions: conflictingPositions.map(pos => ({ row: pos.row, col: pos.col }))\n      }\n    );\n  }\n}\n\n/**\n * 유효한 수 입력 이벤트\n */\nexport class ValidMoveCompleted extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    position: Position,\n    value: CellValue,\n    moveCount: number\n  ) {\n    super(\n      'ValidMoveCompleted',\n      gameId,\n      'SudokuGame',\n      {\n        position: { row: position.row, col: position.col },\n        value: value.value,\n        moveCount\n      }\n    );\n  }\n}\n\n/**\n * 무효한 수 입력 이벤트\n */\nexport class InvalidMoveAttempted extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    position: Position,\n    value: CellValue,\n    conflictingPositions: Position[],\n    mistakeCount: number\n  ) {\n    super(\n      'InvalidMoveAttempted',\n      gameId,\n      'SudokuGame',\n      {\n        position: { row: position.row, col: position.col },\n        value: value.value,\n        conflictingPositions: conflictingPositions.map(pos => ({ row: pos.row, col: pos.col })),\n        mistakeCount\n      }\n    );\n  }\n}\n\n/**\n * 라인 완성 이벤트\n */\nexport class LineCompleted extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    lineType: 'row' | 'column' | 'box',\n    lineIndex: number,\n    completionPosition: Position\n  ) {\n    super(\n      'LineCompleted',\n      gameId,\n      'SudokuGame',\n      {\n        lineType,\n        lineIndex,\n        completionPosition: { row: completionPosition.row, col: completionPosition.col }\n      }\n    );\n  }\n}\n\n/**\n * 게임 완료 이벤트\n */\nexport class GameCompleted extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    difficulty: Difficulty,\n    finalStats: {\n      elapsedTime: number;\n      moveCount: number;\n      mistakeCount: number;\n      hintsUsed: number;\n    }\n  ) {\n    super(\n      'GameCompleted',\n      gameId,\n      'SudokuGame',\n      {\n        difficulty,\n        ...finalStats,\n        completedAt: new Date().toISOString()\n      }\n    );\n  }\n}\n\n/**\n * 게임 일시정지 이벤트\n */\nexport class GamePaused extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    metadata: {\n      elapsedTime: number;\n      moveCount: number;\n    }\n  ) {\n    super(\n      'GamePaused',\n      gameId,\n      'SudokuGame',\n      {\n        ...metadata,\n        pausedAt: new Date().toISOString()\n      }\n    );\n  }\n}\n\n/**\n * 게임 재개 이벤트\n */\nexport class GameResumed extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    metadata: {\n      elapsedTime: number;\n      moveCount: number;\n    }\n  ) {\n    super(\n      'GameResumed',\n      gameId,\n      'SudokuGame',\n      {\n        ...metadata,\n        resumedAt: new Date().toISOString()\n      }\n    );\n  }\n}\n\n/**\n * 힌트 요청 이벤트\n */\nexport class HintRequested extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    position: Position,\n    suggestedValue: CellValue,\n    metadata: {\n      hintsUsed: number;\n      hintType: string;\n      reasoning: string;\n    }\n  ) {\n    super(\n      'HintRequested',\n      gameId,\n      'SudokuGame',\n      {\n        position: { row: position.row, col: position.col },\n        suggestedValue: suggestedValue.value,\n        ...metadata\n      }\n    );\n  }\n}\n\n/**\n * 힌트 사용 이벤트\n */\nexport class HintUsed extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    hintPosition: Position,\n    suggestedValue: CellValue,\n    hintType: 'simple' | 'advanced' | 'strategy',\n    hintsUsedCount: number\n  ) {\n    super(\n      'HintUsed',\n      gameId,\n      'SudokuGame',\n      {\n        hintPosition: { row: hintPosition.row, col: hintPosition.col },\n        suggestedValue: suggestedValue.value,\n        hintType,\n        hintsUsedCount\n      }\n    );\n  }\n}\n\n/**\n * 게임 리셋 이벤트\n */\nexport class GameReset extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    metadata: {\n      previousStats: {\n        moveCount: number;\n        mistakeCount: number;\n        hintsUsed: number;\n        elapsedTime: number;\n      }\n    }\n  ) {\n    super(\n      'GameReset',\n      gameId,\n      'SudokuGame',\n      {\n        ...metadata,\n        resetAt: new Date().toISOString()\n      }\n    );\n  }\n}\n\n/**\n * 셀 선택 이벤트\n */\nexport class CellSelected extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    position: Position,\n    previousPosition?: Position\n  ) {\n    super(\n      'CellSelected',\n      gameId,\n      'SudokuGame',\n      {\n        position: { row: position.row, col: position.col },\n        previousPosition: previousPosition ? { row: previousPosition.row, col: previousPosition.col } : null\n      }\n    );\n  }\n}\n\n/**\n * 숫자 하이라이트 이벤트\n */\nexport class NumberHighlighted extends BaseDomainEvent {\n  constructor(\n    gameId: string,\n    number: number,\n    highlightedCells: Position[]\n  ) {\n    super(\n      'NumberHighlighted',\n      gameId,\n      'SudokuGame',\n      {\n        number,\n        highlightedCells: highlightedCells.map(pos => ({ row: pos.row, col: pos.col })),\n        highlightCount: highlightedCells.length\n      }\n    );\n  }\n}","/**\n * 비즈니스 규칙 엔진\n *\n * 도메인 로직을 규칙 기반으로 표현하고 실행합니다.\n */\n\nexport interface BusinessRule<T = any> {\n  readonly name: string;\n  readonly description: string;\n  readonly priority: number;\n\n  /**\n   * 규칙 조건 검사\n   */\n  isSatisfiedBy(context: T): boolean;\n\n  /**\n   * 규칙 위반 시 에러 메시지\n   */\n  getErrorMessage(context: T): string;\n}\n\n/**\n * 규칙 결과\n */\nexport interface RuleResult {\n  readonly isValid: boolean;\n  readonly violatedRules: ViolatedRule[];\n  readonly context: any;\n}\n\nexport interface ViolatedRule {\n  readonly rule: BusinessRule;\n  readonly errorMessage: string;\n  readonly severity: 'error' | 'warning' | 'info';\n}\n\n/**\n * 비즈니스 규칙 엔진\n */\nexport class BusinessRuleEngine<T = any> {\n  private rules: BusinessRule<T>[] = [];\n\n  /**\n   * 규칙 추가\n   */\n  addRule(rule: BusinessRule<T>): void {\n    this.rules.push(rule);\n    this.sortRulesByPriority();\n  }\n\n  /**\n   * 다중 규칙 추가\n   */\n  addRules(rules: BusinessRule<T>[]): void {\n    this.rules.push(...rules);\n    this.sortRulesByPriority();\n  }\n\n  /**\n   * 규칙 제거\n   */\n  removeRule(ruleName: string): void {\n    this.rules = this.rules.filter(rule => rule.name !== ruleName);\n  }\n\n  /**\n   * 모든 규칙 검증\n   */\n  validate(context: T): RuleResult {\n    const violatedRules: ViolatedRule[] = [];\n\n    for (const rule of this.rules) {\n      if (!rule.isSatisfiedBy(context)) {\n        violatedRules.push({\n          rule,\n          errorMessage: rule.getErrorMessage(context),\n          severity: 'error'\n        });\n      }\n    }\n\n    return {\n      isValid: violatedRules.length === 0,\n      violatedRules,\n      context\n    };\n  }\n\n  /**\n   * 특정 규칙만 검증\n   */\n  validateRule(ruleName: string, context: T): RuleResult {\n    const rule = this.rules.find(r => r.name === ruleName);\n\n    if (!rule) {\n      throw new Error(`Rule '${ruleName}' not found`);\n    }\n\n    const violatedRules: ViolatedRule[] = [];\n\n    if (!rule.isSatisfiedBy(context)) {\n      violatedRules.push({\n        rule,\n        errorMessage: rule.getErrorMessage(context),\n        severity: 'error'\n      });\n    }\n\n    return {\n      isValid: violatedRules.length === 0,\n      violatedRules,\n      context\n    };\n  }\n\n  /**\n   * 조건부 검증 (특정 조건을 만족하는 규칙만)\n   */\n  validateIf(predicate: (rule: BusinessRule<T>) => boolean, context: T): RuleResult {\n    const applicableRules = this.rules.filter(predicate);\n    const violatedRules: ViolatedRule[] = [];\n\n    for (const rule of applicableRules) {\n      if (!rule.isSatisfiedBy(context)) {\n        violatedRules.push({\n          rule,\n          errorMessage: rule.getErrorMessage(context),\n          severity: 'error'\n        });\n      }\n    }\n\n    return {\n      isValid: violatedRules.length === 0,\n      violatedRules,\n      context\n    };\n  }\n\n  /**\n   * 등록된 규칙 목록 조회\n   */\n  getRules(): readonly BusinessRule<T>[] {\n    return [...this.rules];\n  }\n\n  /**\n   * 규칙 수 조회\n   */\n  getRuleCount(): number {\n    return this.rules.length;\n  }\n\n  /**\n   * 모든 규칙 제거\n   */\n  clearRules(): void {\n    this.rules = [];\n  }\n\n  private sortRulesByPriority(): void {\n    this.rules.sort((a, b) => b.priority - a.priority);\n  }\n}\n\n/**\n * 복합 비즈니스 규칙 (AND/OR 조건)\n */\nexport class CompositeRule<T> implements BusinessRule<T> {\n  constructor(\n    public readonly name: string,\n    public readonly description: string,\n    public readonly priority: number,\n    private readonly rules: BusinessRule<T>[],\n    private readonly operator: 'AND' | 'OR' = 'AND'\n  ) {}\n\n  isSatisfiedBy(context: T): boolean {\n    if (this.operator === 'AND') {\n      return this.rules.every(rule => rule.isSatisfiedBy(context));\n    } else {\n      return this.rules.some(rule => rule.isSatisfiedBy(context));\n    }\n  }\n\n  getErrorMessage(context: T): string {\n    const violatedRules = this.rules.filter(rule => !rule.isSatisfiedBy(context));\n\n    if (violatedRules.length === 0) {\n      return '';\n    }\n\n    const messages = violatedRules.map(rule => rule.getErrorMessage(context));\n\n    if (this.operator === 'AND') {\n      return `All conditions must be met: ${messages.join(', ')}`;\n    } else {\n      return `At least one condition must be met: ${messages.join(' OR ')}`;\n    }\n  }\n}\n\n/**\n * 조건부 비즈니스 규칙\n */\nexport class ConditionalRule<T> implements BusinessRule<T> {\n  constructor(\n    public readonly name: string,\n    public readonly description: string,\n    public readonly priority: number,\n    private readonly condition: (context: T) => boolean,\n    private readonly rule: BusinessRule<T>\n  ) {}\n\n  isSatisfiedBy(context: T): boolean {\n    if (!this.condition(context)) {\n      return true; // 조건이 맞지 않으면 규칙을 적용하지 않음\n    }\n\n    return this.rule.isSatisfiedBy(context);\n  }\n\n  getErrorMessage(context: T): string {\n    if (!this.condition(context)) {\n      return '';\n    }\n\n    return this.rule.getErrorMessage(context);\n  }\n}\n\n/**\n * 기본 비즈니스 규칙 구현\n */\nexport abstract class BaseBusinessRule<T> implements BusinessRule<T> {\n  constructor(\n    public readonly name: string,\n    public readonly description: string,\n    public readonly priority: number = 0\n  ) {}\n\n  abstract isSatisfiedBy(context: T): boolean;\n  abstract getErrorMessage(context: T): string;\n}\n\n/**\n * 람다 기반 비즈니스 규칙\n */\nexport class LambdaRule<T> extends BaseBusinessRule<T> {\n  constructor(\n    name: string,\n    description: string,\n    priority: number,\n    private readonly predicate: (context: T) => boolean,\n    private readonly errorMessageFactory: (context: T) => string\n  ) {\n    super(name, description, priority);\n  }\n\n  isSatisfiedBy(context: T): boolean {\n    return this.predicate(context);\n  }\n\n  getErrorMessage(context: T): string {\n    return this.errorMessageFactory(context);\n  }\n}","import { BaseBusinessRule, BusinessRuleEngine } from '../../common/rules/BusinessRule.js';\nimport { Position } from '../value-objects/Position.js';\nimport { CellValue } from '../value-objects/CellValue.js';\nimport { Difficulty } from '../entities/GameState.js';\n\n/**\n * 스도쿠 비즈니스 규칙 컨텍스트\n */\nexport interface SudokuMoveContext {\n  readonly grid: any; // SudokuGrid 타입\n  readonly position: Position;\n  readonly value: CellValue;\n  readonly gameState: any; // GameState 타입\n}\n\nexport interface SudokuGameContext {\n  readonly game: any; // SudokuGame 타입\n  readonly action: string;\n  readonly metadata?: Record<string, any>;\n}\n\n/**\n * 스도쿠 기본 규칙들\n */\n\n/**\n * 주어진 셀 수정 금지 규칙\n */\nexport class CannotModifyGivenCellRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'CannotModifyGivenCell',\n      'Given cells cannot be modified',\n      100 // 높은 우선순위\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    const cell = context.grid.getCell(context.position);\n    return !cell.isGiven;\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    return `Cannot modify given cell at (${context.position.row}, ${context.position.col})`;\n  }\n}\n\n/**\n * 행 중복 금지 규칙\n */\nexport class UniqueInRowRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'UniqueInRow',\n      'Numbers must be unique within each row',\n      90\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    if (context.value.isEmpty()) return true;\n\n    for (let col = 0; col < 9; col++) {\n      if (col === context.position.col) continue;\n\n      const cell = context.grid.getCell(new Position(context.position.row, col));\n      if (!cell.isEmpty() && cell.value.equals(context.value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    return `Number ${context.value.value} already exists in row ${context.position.row + 1}`;\n  }\n}\n\n/**\n * 열 중복 금지 규칙\n */\nexport class UniqueInColumnRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'UniqueInColumn',\n      'Numbers must be unique within each column',\n      90\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    if (context.value.isEmpty()) return true;\n\n    for (let row = 0; row < 9; row++) {\n      if (row === context.position.row) continue;\n\n      const cell = context.grid.getCell(new Position(row, context.position.col));\n      if (!cell.isEmpty() && cell.value.equals(context.value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    return `Number ${context.value.value} already exists in column ${context.position.col + 1}`;\n  }\n}\n\n/**\n * 3x3 박스 중복 금지 규칙\n */\nexport class UniqueInBoxRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'UniqueInBox',\n      'Numbers must be unique within each 3x3 box',\n      90\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    if (context.value.isEmpty()) return true;\n\n    const boxStartRow = Math.floor(context.position.row / 3) * 3;\n    const boxStartCol = Math.floor(context.position.col / 3) * 3;\n\n    for (let row = boxStartRow; row < boxStartRow + 3; row++) {\n      for (let col = boxStartCol; col < boxStartCol + 3; col++) {\n        if (row === context.position.row && col === context.position.col) continue;\n\n        const cell = context.grid.getCell(new Position(row, col));\n        if (!cell.isEmpty() && cell.value.equals(context.value)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    const boxRow = Math.floor(context.position.row / 3) + 1;\n    const boxCol = Math.floor(context.position.col / 3) + 1;\n    return `Number ${context.value.value} already exists in box (${boxRow}, ${boxCol})`;\n  }\n}\n\n/**\n * 유효한 셀 값 규칙\n */\nexport class ValidCellValueRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'ValidCellValue',\n      'Cell value must be between 1-9 or empty',\n      80\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    return context.value.isValid();\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    return `Invalid cell value: ${context.value.value}. Must be between 1-9 or empty.`;\n  }\n}\n\n/**\n * 유효한 위치 규칙\n */\nexport class ValidPositionRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'ValidPosition',\n      'Position must be within grid bounds',\n      70\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    return context.position.isValid();\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    return `Invalid position: (${context.position.row}, ${context.position.col}). Must be within 0-8 range.`;\n  }\n}\n\n/**\n * 게임 진행 가능 규칙\n */\nexport class GameInProgressRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'GameInProgress',\n      'Game must be in progress to make moves',\n      60\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    return !context.gameState.isComplete && !context.gameState.isPaused;\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    if (context.gameState.isComplete) {\n      return 'Cannot make moves in completed game';\n    }\n    if (context.gameState.isPaused) {\n      return 'Cannot make moves while game is paused';\n    }\n    return 'Game is not in progress';\n  }\n}\n\n/**\n * 최대 실수 횟수 규칙\n */\nexport class MaxMistakesRule extends BaseBusinessRule<SudokuMoveContext> {\n  private readonly maxMistakes: number;\n\n  constructor(maxMistakes: number = 3) {\n    super(\n      'MaxMistakes',\n      `Maximum ${maxMistakes} mistakes allowed`,\n      50\n    );\n    this.maxMistakes = maxMistakes;\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    return context.gameState.mistakeCount < this.maxMistakes;\n  }\n\n  getErrorMessage(_context: SudokuMoveContext): string {\n    return `Maximum mistakes (${this.maxMistakes}) reached. Game over.`;\n  }\n}\n\n/**\n * 스도쿠 비즈니스 규칙 팩토리\n */\nexport class SudokuRuleFactory {\n  /**\n   * 기본 움직임 규칙 엔진 생성\n   */\n  static createMoveValidationEngine(): BusinessRuleEngine<SudokuMoveContext> {\n    const engine = new BusinessRuleEngine<SudokuMoveContext>();\n\n    engine.addRules([\n      new ValidPositionRule(),\n      new ValidCellValueRule(),\n      new CannotModifyGivenCellRule(),\n      new GameInProgressRule(),\n      new UniqueInRowRule(),\n      new UniqueInColumnRule(),\n      new UniqueInBoxRule()\n    ]);\n\n    return engine;\n  }\n\n  /**\n   * 난이도별 규칙 엔진 생성\n   */\n  static createDifficultySpecificEngine(difficulty: Difficulty): BusinessRuleEngine<SudokuMoveContext> {\n    const engine = this.createMoveValidationEngine();\n\n    switch (difficulty) {\n      case Difficulty.EASY:\n        // Easy 모드는 무제한 실수 허용\n        break;\n\n      case Difficulty.MEDIUM:\n        engine.addRule(new MaxMistakesRule(5));\n        break;\n\n      case Difficulty.HARD:\n        engine.addRule(new MaxMistakesRule(3));\n        break;\n\n      case Difficulty.EXPERT:\n        engine.addRule(new MaxMistakesRule(1));\n        break;\n    }\n\n    return engine;\n  }\n\n  /**\n   * 게임 상태 검증 규칙 엔진 생성\n   */\n  static createGameStateEngine(): BusinessRuleEngine<SudokuGameContext> {\n    const engine = new BusinessRuleEngine<SudokuGameContext>();\n\n    // 게임 상태 관련 규칙들 추가\n    // 예: 일시정지 중인 게임에 대한 액션 제한 등\n\n    return engine;\n  }\n}\n\n/**\n * 고급 스도쿠 규칙들 (솔빙 전략 기반)\n */\n\n/**\n * Naked Single 규칙\n */\nexport class NakedSingleRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'NakedSingle',\n      'If a cell has only one possible value, it must be that value',\n      40\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    if (context.value.isEmpty()) return true;\n\n    const possibleValues = this.getPossibleValues(context.grid, context.position);\n    return possibleValues.length === 1 && possibleValues[0] === context.value.value;\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    const possibleValues = this.getPossibleValues(context.grid, context.position);\n    if (possibleValues.length === 1) {\n      return `Cell must contain ${possibleValues[0]} (naked single)`;\n    }\n    return `Invalid move for naked single constraint`;\n  }\n\n  private getPossibleValues(grid: any, position: Position): number[] {\n    const possible: number[] = [];\n\n    for (let num = 1; num <= 9; num++) {\n      const testValue = new CellValue(num);\n      const context = { grid, position, value: testValue, gameState: null };\n\n      const rowRule = new UniqueInRowRule();\n      const colRule = new UniqueInColumnRule();\n      const boxRule = new UniqueInBoxRule();\n\n      if (rowRule.isSatisfiedBy(context) &&\n          colRule.isSatisfiedBy(context) &&\n          boxRule.isSatisfiedBy(context)) {\n        possible.push(num);\n      }\n    }\n\n    return possible;\n  }\n}\n\n/**\n * Hidden Single 규칙\n */\nexport class HiddenSingleRule extends BaseBusinessRule<SudokuMoveContext> {\n  constructor() {\n    super(\n      'HiddenSingle',\n      'If a value can only go in one cell in a unit, it must go there',\n      30\n    );\n  }\n\n  isSatisfiedBy(context: SudokuMoveContext): boolean {\n    if (context.value.isEmpty()) return true;\n\n    // 행, 열, 박스에서 해당 값이 들어갈 수 있는 유일한 위치인지 확인\n    return this.isHiddenSingleInRow(context) ||\n           this.isHiddenSingleInColumn(context) ||\n           this.isHiddenSingleInBox(context);\n  }\n\n  getErrorMessage(context: SudokuMoveContext): string {\n    return `Value ${context.value.value} must be placed at this position (hidden single)`;\n  }\n\n  private isHiddenSingleInRow(context: SudokuMoveContext): boolean {\n    let possiblePositions = 0;\n\n    for (let col = 0; col < 9; col++) {\n      const pos = new Position(context.position.row, col);\n      const cell = context.grid.getCell(pos);\n\n      if (cell.isEmpty()) {\n        const testContext = { ...context, position: pos };\n        const colRule = new UniqueInColumnRule();\n        const boxRule = new UniqueInBoxRule();\n\n        if (colRule.isSatisfiedBy(testContext) && boxRule.isSatisfiedBy(testContext)) {\n          possiblePositions++;\n        }\n      }\n    }\n\n    return possiblePositions === 1;\n  }\n\n  private isHiddenSingleInColumn(context: SudokuMoveContext): boolean {\n    let possiblePositions = 0;\n\n    for (let row = 0; row < 9; row++) {\n      const pos = new Position(row, context.position.col);\n      const cell = context.grid.getCell(pos);\n\n      if (cell.isEmpty()) {\n        const testContext = { ...context, position: pos };\n        const rowRule = new UniqueInRowRule();\n        const boxRule = new UniqueInBoxRule();\n\n        if (rowRule.isSatisfiedBy(testContext) && boxRule.isSatisfiedBy(testContext)) {\n          possiblePositions++;\n        }\n      }\n    }\n\n    return possiblePositions === 1;\n  }\n\n  private isHiddenSingleInBox(context: SudokuMoveContext): boolean {\n    let possiblePositions = 0;\n    const boxStartRow = Math.floor(context.position.row / 3) * 3;\n    const boxStartCol = Math.floor(context.position.col / 3) * 3;\n\n    for (let row = boxStartRow; row < boxStartRow + 3; row++) {\n      for (let col = boxStartCol; col < boxStartCol + 3; col++) {\n        const pos = new Position(row, col);\n        const cell = context.grid.getCell(pos);\n\n        if (cell.isEmpty()) {\n          const testContext = { ...context, position: pos };\n          const rowRule = new UniqueInRowRule();\n          const colRule = new UniqueInColumnRule();\n\n          if (rowRule.isSatisfiedBy(testContext) && colRule.isSatisfiedBy(testContext)) {\n            possiblePositions++;\n          }\n        }\n      }\n    }\n\n    return possiblePositions === 1;\n  }\n}","import { BusinessRuleEngine } from '../../common/rules/BusinessRule.js';\nimport { SudokuRuleFactory, SudokuMoveContext } from '../rules/SudokuBusinessRules.js';\nimport { Position } from '../value-objects/Position.js';\nimport { CellValue } from '../value-objects/CellValue.js';\nimport { Difficulty } from '../entities/GameState.js';\nimport { DomainEventPublisher } from '../../common/events/DomainEventPublisher.js';\nimport { MoveAttempted, ValidMoveCompleted, InvalidMoveAttempted } from '../events/SudokuDomainEvents.js';\n\n/**\n * 향상된 그리드 검증 서비스\n *\n * 비즈니스 규칙 엔진을 사용하여 스도쿠 규칙을 검증합니다.\n */\n\nexport interface ValidationResult {\n  readonly isValid: boolean;\n  readonly conflictingPositions: Position[];\n  readonly errorMessages: string[];\n  readonly violatedRules: string[];\n  readonly suggestions?: ValidationSuggestion[];\n}\n\nexport interface ValidationSuggestion {\n  readonly type: 'naked_single' | 'hidden_single' | 'elimination';\n  readonly position: Position;\n  readonly value: CellValue;\n  readonly reasoning: string;\n}\n\nexport class EnhancedGridValidationService {\n  private moveValidationEngine: BusinessRuleEngine<SudokuMoveContext>;\n  private eventPublisher?: DomainEventPublisher;\n\n  constructor(\n    difficulty: Difficulty = Difficulty.MEDIUM,\n    eventPublisher?: DomainEventPublisher\n  ) {\n    this.moveValidationEngine = SudokuRuleFactory.createDifficultySpecificEngine(difficulty);\n    this.eventPublisher = eventPublisher;\n  }\n\n  /**\n   * 수 입력 검증 (향상된 버전)\n   */\n  async validateMove(\n    grid: any,\n    position: Position,\n    value: CellValue,\n    gameState?: any\n  ): Promise<ValidationResult> {\n    const context: SudokuMoveContext = {\n      grid,\n      position,\n      value,\n      gameState: gameState || { isComplete: false, isPaused: false, mistakeCount: 0 }\n    };\n\n    const ruleResult = this.moveValidationEngine.validate(context);\n\n    const conflictingPositions = this.getConflictingPositions(grid, position, value);\n    const suggestions = await this.generateSuggestions(grid, position, value);\n\n    const validationResult: ValidationResult = {\n      isValid: ruleResult.isValid,\n      conflictingPositions,\n      errorMessages: ruleResult.violatedRules.map(vr => vr.errorMessage),\n      violatedRules: ruleResult.violatedRules.map(vr => vr.rule.name),\n      suggestions: ruleResult.isValid ? undefined : suggestions\n    };\n\n    // 도메인 이벤트 발행\n    if (this.eventPublisher && gameState) {\n      const gameId = gameState.id || 'unknown';\n\n      await this.eventPublisher.publish(\n        new MoveAttempted(gameId, position, value, ruleResult.isValid, conflictingPositions)\n      );\n\n      if (ruleResult.isValid) {\n        await this.eventPublisher.publish(\n          new ValidMoveCompleted(gameId, position, value, gameState.moveCount + 1)\n        );\n      } else {\n        await this.eventPublisher.publish(\n          new InvalidMoveAttempted(gameId, position, value, conflictingPositions, gameState.mistakeCount + 1)\n        );\n      }\n    }\n\n    return validationResult;\n  }\n\n  /**\n   * 그리드 완료 여부 검사\n   */\n  isGridComplete(grid: any): boolean {\n    console.log('Checking if grid is complete...');\n\n    // 1. 모든 셀이 채워져 있는지 확인\n    let filledCells = 0;\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        const cell = grid.getCell(new Position(row, col));\n        if (cell.isEmpty()) {\n          console.log(`Empty cell found at (${row}, ${col}), grid not complete`);\n          return false;\n        }\n        filledCells++;\n      }\n    }\n\n    console.log(`All ${filledCells} cells are filled. Checking for conflicts...`);\n\n    // 2. 간단한 스도쿠 규칙 검사 (중복 값 확인)\n    // 행 검사\n    for (let row = 0; row < 9; row++) {\n      const seen = new Set();\n      for (let col = 0; col < 9; col++) {\n        const cell = grid.getCell(new Position(row, col));\n        const value = cell.value.toString();\n        if (seen.has(value)) {\n          console.log(`Duplicate value ${value} in row ${row}`);\n          return false;\n        }\n        seen.add(value);\n      }\n    }\n\n    // 열 검사\n    for (let col = 0; col < 9; col++) {\n      const seen = new Set();\n      for (let row = 0; row < 9; row++) {\n        const cell = grid.getCell(new Position(row, col));\n        const value = cell.value.toString();\n        if (seen.has(value)) {\n          console.log(`Duplicate value ${value} in column ${col}`);\n          return false;\n        }\n        seen.add(value);\n      }\n    }\n\n    // 3x3 박스 검사\n    for (let boxRow = 0; boxRow < 3; boxRow++) {\n      for (let boxCol = 0; boxCol < 3; boxCol++) {\n        const seen = new Set();\n        for (let row = boxRow * 3; row < boxRow * 3 + 3; row++) {\n          for (let col = boxCol * 3; col < boxCol * 3 + 3; col++) {\n            const cell = grid.getCell(new Position(row, col));\n            const value = cell.value.toString();\n            if (seen.has(value)) {\n              console.log(`Duplicate value ${value} in box (${boxRow}, ${boxCol})`);\n              return false;\n            }\n            seen.add(value);\n          }\n        }\n      }\n    }\n\n    console.log('🎉 Grid is complete and valid!');\n    return true;\n  }\n\n  /**\n   * 그리드 유효성 전체 검사\n   */\n  validateCompleteGrid(grid: any): ValidationResult {\n    const allErrors: string[] = [];\n    const allViolatedRules: string[] = [];\n    const allConflictingPositions: Position[] = [];\n\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        const position = new Position(row, col);\n        const cell = grid.getCell(position);\n\n        if (!cell.isEmpty()) {\n          const context: SudokuMoveContext = {\n            grid,\n            position,\n            value: cell.value,\n            gameState: { isComplete: false, isPaused: false, mistakeCount: 0 }\n          };\n\n          const result = this.moveValidationEngine.validate(context);\n          if (!result.isValid) {\n            allErrors.push(...result.violatedRules.map(vr => vr.errorMessage));\n            allViolatedRules.push(...result.violatedRules.map(vr => vr.rule.name));\n            allConflictingPositions.push(...this.getConflictingPositions(grid, position, cell.value));\n          }\n        }\n      }\n    }\n\n    return {\n      isValid: allErrors.length === 0,\n      conflictingPositions: this.removeDuplicatePositions(allConflictingPositions),\n      errorMessages: [...new Set(allErrors)],\n      violatedRules: [...new Set(allViolatedRules)]\n    };\n  }\n\n  /**\n   * 충돌하는 위치들 찾기\n   */\n  private getConflictingPositions(grid: any, position: Position, value: CellValue): Position[] {\n    if (value.isEmpty()) return [];\n\n    const conflicts: Position[] = [];\n\n    // 같은 행에서 충돌 찾기\n    for (let col = 0; col < 9; col++) {\n      if (col !== position.col) {\n        const cell = grid.getCell(new Position(position.row, col));\n        if (!cell.isEmpty() && cell.value.equals(value)) {\n          conflicts.push(new Position(position.row, col));\n        }\n      }\n    }\n\n    // 같은 열에서 충돌 찾기\n    for (let row = 0; row < 9; row++) {\n      if (row !== position.row) {\n        const cell = grid.getCell(new Position(row, position.col));\n        if (!cell.isEmpty() && cell.value.equals(value)) {\n          conflicts.push(new Position(row, position.col));\n        }\n      }\n    }\n\n    // 같은 3x3 박스에서 충돌 찾기\n    const boxStartRow = Math.floor(position.row / 3) * 3;\n    const boxStartCol = Math.floor(position.col / 3) * 3;\n\n    for (let row = boxStartRow; row < boxStartRow + 3; row++) {\n      for (let col = boxStartCol; col < boxStartCol + 3; col++) {\n        if (row !== position.row || col !== position.col) {\n          const cell = grid.getCell(new Position(row, col));\n          if (!cell.isEmpty() && cell.value.equals(value)) {\n            conflicts.push(new Position(row, col));\n          }\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * 검증 제안사항 생성\n   */\n  private async generateSuggestions(\n    grid: any,\n    position: Position,\n    value: CellValue\n  ): Promise<ValidationSuggestion[]> {\n    const suggestions: ValidationSuggestion[] = [];\n\n    // 해당 위치에 가능한 값들 찾기\n    const possibleValues = await this.getPossibleValues(grid, position);\n\n    if (possibleValues.length === 1) {\n      suggestions.push({\n        type: 'naked_single',\n        position,\n        value: new CellValue(possibleValues[0]),\n        reasoning: `Only ${possibleValues[0]} is possible in this cell`\n      });\n    } else if (possibleValues.length > 1) {\n      // 제거법 제안\n      const invalidReasons = this.getInvalidReasons(grid, position, value);\n      if (invalidReasons.length > 0) {\n        suggestions.push({\n          type: 'elimination',\n          position,\n          value,\n          reasoning: `Cannot place ${value.value}: ${invalidReasons.join(', ')}`\n        });\n      }\n    }\n\n    // Hidden single 검사\n    for (const num of possibleValues) {\n      if (await this.isHiddenSingle(grid, position, new CellValue(num))) {\n        suggestions.push({\n          type: 'hidden_single',\n          position,\n          value: new CellValue(num),\n          reasoning: `${num} can only go in this position within its unit`\n        });\n      }\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * 가능한 값들 조회\n   */\n  private async getPossibleValues(grid: any, position: Position): Promise<number[]> {\n    const possible: number[] = [];\n\n    for (let num = 1; num <= 9; num++) {\n      const testValue = new CellValue(num);\n      const context: SudokuMoveContext = {\n        grid,\n        position,\n        value: testValue,\n        gameState: { isComplete: false, isPaused: false, mistakeCount: 0 }\n      };\n\n      // 기본 유효성 규칙만 체크 (given cell, game state 등 제외)\n      const basicEngine = new BusinessRuleEngine<SudokuMoveContext>();\n      basicEngine.addRules([\n        new (await import('../rules/SudokuBusinessRules.js')).UniqueInRowRule(),\n        new (await import('../rules/SudokuBusinessRules.js')).UniqueInColumnRule(),\n        new (await import('../rules/SudokuBusinessRules.js')).UniqueInBoxRule()\n      ]);\n\n      const result = basicEngine.validate(context);\n      if (result.isValid) {\n        possible.push(num);\n      }\n    }\n\n    return possible;\n  }\n\n  /**\n   * 무효한 이유들 조회\n   */\n  private getInvalidReasons(grid: any, position: Position, value: CellValue): string[] {\n    const reasons: string[] = [];\n\n    // 행 충돌 검사\n    for (let col = 0; col < 9; col++) {\n      if (col !== position.col) {\n        const cell = grid.getCell(new Position(position.row, col));\n        if (!cell.isEmpty() && cell.value.equals(value)) {\n          reasons.push(`conflicts with row ${position.row + 1}`);\n          break;\n        }\n      }\n    }\n\n    // 열 충돌 검사\n    for (let row = 0; row < 9; row++) {\n      if (row !== position.row) {\n        const cell = grid.getCell(new Position(row, position.col));\n        if (!cell.isEmpty() && cell.value.equals(value)) {\n          reasons.push(`conflicts with column ${position.col + 1}`);\n          break;\n        }\n      }\n    }\n\n    // 박스 충돌 검사\n    const boxStartRow = Math.floor(position.row / 3) * 3;\n    const boxStartCol = Math.floor(position.col / 3) * 3;\n\n    for (let row = boxStartRow; row < boxStartRow + 3; row++) {\n      for (let col = boxStartCol; col < boxStartCol + 3; col++) {\n        if (row !== position.row || col !== position.col) {\n          const cell = grid.getCell(new Position(row, col));\n          if (!cell.isEmpty() && cell.value.equals(value)) {\n            const boxNum = Math.floor(position.row / 3) * 3 + Math.floor(position.col / 3) + 1;\n            reasons.push(`conflicts with box ${boxNum}`);\n            break;\n          }\n        }\n      }\n    }\n\n    return reasons;\n  }\n\n  /**\n   * Hidden single 여부 확인\n   */\n  private async isHiddenSingle(grid: any, position: Position, value: CellValue): Promise<boolean> {\n    // 행에서 유일한 위치인지 확인\n    let possibleInRow = 0;\n    for (let col = 0; col < 9; col++) {\n      const pos = new Position(position.row, col);\n      if (await this.canPlaceValue(grid, pos, value)) {\n        possibleInRow++;\n      }\n    }\n\n    if (possibleInRow === 1) return true;\n\n    // 열에서 유일한 위치인지 확인\n    let possibleInCol = 0;\n    for (let row = 0; row < 9; row++) {\n      const pos = new Position(row, position.col);\n      if (await this.canPlaceValue(grid, pos, value)) {\n        possibleInCol++;\n      }\n    }\n\n    if (possibleInCol === 1) return true;\n\n    // 박스에서 유일한 위치인지 확인\n    const boxStartRow = Math.floor(position.row / 3) * 3;\n    const boxStartCol = Math.floor(position.col / 3) * 3;\n    let possibleInBox = 0;\n\n    for (let row = boxStartRow; row < boxStartRow + 3; row++) {\n      for (let col = boxStartCol; col < boxStartCol + 3; col++) {\n        const pos = new Position(row, col);\n        if (await this.canPlaceValue(grid, pos, value)) {\n          possibleInBox++;\n        }\n      }\n    }\n\n    return possibleInBox === 1;\n  }\n\n  /**\n   * 특정 위치에 값을 놓을 수 있는지 확인\n   */\n  private async canPlaceValue(grid: any, position: Position, value: CellValue): Promise<boolean> {\n    const cell = grid.getCell(position);\n    if (!cell.isEmpty()) return false;\n\n    const possibleValues = await this.getPossibleValues(grid, position);\n    return possibleValues.includes(value.value || 0);\n  }\n\n  /**\n   * 중복 위치 제거\n   */\n  private removeDuplicatePositions(positions: Position[]): Position[] {\n    const unique: Position[] = [];\n    const seen = new Set<string>();\n\n    for (const pos of positions) {\n      const key = `${pos.row},${pos.col}`;\n      if (!seen.has(key)) {\n        seen.add(key);\n        unique.push(pos);\n      }\n    }\n\n    return unique;\n  }\n\n  /**\n   * 난이도 변경\n   */\n  setDifficulty(difficulty: Difficulty): void {\n    this.moveValidationEngine = SudokuRuleFactory.createDifficultySpecificEngine(difficulty);\n  }\n\n  /**\n   * 이벤트 발행자 설정\n   */\n  setEventPublisher(eventPublisher: DomainEventPublisher): void {\n    this.eventPublisher = eventPublisher;\n  }\n}","import { SudokuGame } from '../../domain/sudoku/aggregates/Game';\nimport { SudokuGrid } from '../../domain/sudoku/aggregates/Grid';\nimport { GameState, Difficulty } from '../../domain/sudoku/entities/GameState';\nimport { Position } from '../../domain/sudoku/value-objects/Position';\nimport { CellValue } from '../../domain/sudoku/value-objects/CellValue';\nimport { SudokuValidationService } from '../../domain/sudoku/services/GridValidationService';\nimport { SudokuGeneratorService } from '../../domain/sudoku/services/PuzzleGenerationService';\nimport { LineCompletionDetectionService } from '../../domain/sudoku/services/CompletionDetectionService';\nimport { LineCompletionEffect, EffectAnimation } from '../../domain/effects/entities/LineCompletionEffect';\nimport { GameRepository } from '../../domain/sudoku/repositories/GameRepository';\nimport { DomainEventPublisher } from '../../domain/common/events/DomainEventPublisher.js';\nimport {\n  GameStarted,\n  GameCompleted,\n  HintRequested,\n  GamePaused,\n  GameResumed,\n  GameReset\n} from '../../domain/sudoku/events/SudokuDomainEvents.js';\nimport { EnhancedGridValidationService } from '../../domain/sudoku/services/EnhancedGridValidationService.js';\n\nexport interface MoveResult {\n  success: boolean;\n  game: SudokuGame;\n  isComplete: boolean;\n  conflictingPositions: Position[];\n  lineCompletionEffects: LineCompletionEffect[];\n}\n\nexport interface HintResult {\n  success: boolean;\n  game: SudokuGame;\n  position: Position;\n  value: CellValue;\n}\n\nexport class GameService {\n  private readonly lineCompletionDetectionService: LineCompletionDetectionService;\n  private readonly enhancedValidationService: EnhancedGridValidationService;\n\n  constructor(\n    private readonly gameRepository: GameRepository,\n    private readonly validationService: SudokuValidationService,\n    private readonly eventPublisher?: DomainEventPublisher\n  ) {\n    this.lineCompletionDetectionService = new LineCompletionDetectionService();\n    this.enhancedValidationService = new EnhancedGridValidationService(\n      Difficulty.MEDIUM,\n      this.eventPublisher\n    );\n  }\n\n  async createNewGame(difficulty: Difficulty): Promise<SudokuGame> {\n    const gameId = this.generateGameId();\n    const grid = await this.generateSudokuGrid(difficulty);\n    const state = GameState.create(gameId, difficulty);\n\n    const game = SudokuGame.create(gameId, grid, state);\n    await this.gameRepository.save(game);\n\n    // 게임 시작 이벤트 발행\n    if (this.eventPublisher) {\n      await this.eventPublisher.publish(\n        new GameStarted(gameId, difficulty, {\n          gridSize: 9,\n          clueCount: grid.getFilledCellCount()\n        })\n      );\n    }\n\n    return game;\n  }\n\n  async loadGame(gameId: string): Promise<SudokuGame | null> {\n    return await this.gameRepository.load(gameId);\n  }\n\n  async saveGame(game: SudokuGame): Promise<void> {\n    await this.gameRepository.save(game);\n  }\n\n  async deleteGame(gameId: string): Promise<void> {\n    await this.gameRepository.delete(gameId);\n  }\n\n  async makeMove(game: SudokuGame, position: Position, value: CellValue): Promise<MoveResult> {\n    const cell = game.grid.getCell(position);\n\n    if (cell.isGiven) {\n      return this.createMoveResult(false, game, false, [], []);\n    }\n\n    // 향상된 검증 서비스 사용 (도메인 이벤트 포함)\n    const validation = await this.enhancedValidationService.validateMove(\n      game.grid,\n      position,\n      value,\n      game.state\n    );\n\n    const newGrid = game.grid.setCell(position, value);\n\n    let newState = game.state.addMove();\n    if (!validation.isValid) {\n      newState = newState.addMistake();\n    }\n\n    const updatedGame = game.updateGrid(newGrid).updateState(newState);\n    const isComplete = this.enhancedValidationService.isGridComplete(newGrid);\n\n    // 디버깅을 위한 로깅 추가\n    console.log('Move validation result:', {\n      position: position.toString(),\n      value: value.toString(),\n      isValid: validation.isValid,\n      isComplete,\n      filledCells: newGrid.getFilledCellCount(),\n      totalCells: 81\n    });\n\n    // Detect line completions only for valid moves\n    let lineCompletionEffects: LineCompletionEffect[] = [];\n    if (validation.isValid && !value.isEmpty()) {\n      const completions = this.lineCompletionDetectionService.detectCompletions(newGrid, position);\n      // 기본적으로 RADIAL 이펙트 사용 (중심에서 퍼지는 효과)\n      lineCompletionEffects = this.lineCompletionDetectionService.createEffectsFromCompletions(\n        completions,\n        EffectAnimation.RADIAL\n      );\n    }\n\n    const finalGame = isComplete ? updatedGame.updateState(newState.complete()) : updatedGame;\n\n    // 게임 완료 이벤트 발행\n    if (isComplete && this.eventPublisher) {\n      await this.eventPublisher.publish(\n        new GameCompleted(game.state.gameId, game.state.difficulty, {\n          elapsedTime: finalGame.state.elapsedTime,\n          moveCount: finalGame.state.moveCount,\n          mistakeCount: finalGame.state.mistakeCount,\n          hintsUsed: finalGame.state.hintsUsed\n        })\n      );\n    }\n\n    await this.saveGame(finalGame);\n\n    return this.createMoveResult(true, finalGame, isComplete, validation.conflictingPositions, lineCompletionEffects);\n  }\n\n  private createMoveResult(success: boolean, game: SudokuGame, isComplete: boolean, conflictingPositions: Position[], lineCompletionEffects: LineCompletionEffect[]): MoveResult {\n    return { success, game, isComplete, conflictingPositions, lineCompletionEffects };\n  }\n\n  async getHint(game: SudokuGame): Promise<HintResult | null> {\n    const emptyCells = game.grid.getEmptyCells();\n\n    if (emptyCells.length === 0) {\n      return null;\n    }\n\n    for (const cell of emptyCells) {\n      const possibleValues = this.validationService.getPossibleValues(game.grid, cell.position);\n\n      if (possibleValues.length === 1) {\n        const hintValue = possibleValues[0];\n        const newState = game.state.addHint();\n        const updatedGame = game.updateState(newState);\n\n        // 힌트 요청 이벤트 발행\n        if (this.eventPublisher) {\n          await this.eventPublisher.publish(\n            new HintRequested(game.state.gameId, cell.position, hintValue, {\n              hintsUsed: updatedGame.state.hintsUsed,\n              hintType: 'naked_single',\n              reasoning: `Only ${hintValue.value} is possible at this position`\n            })\n          );\n        }\n\n        await this.saveGame(updatedGame);\n\n        return {\n          success: true,\n          game: updatedGame,\n          position: cell.position,\n          value: hintValue\n        };\n      }\n    }\n\n    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];\n    const possibleValues = this.validationService.getPossibleValues(game.grid, randomCell.position);\n\n    if (possibleValues.length > 0) {\n      const hintValue = possibleValues[0];\n      const newState = game.state.addHint();\n      const updatedGame = game.updateState(newState);\n\n      // 힌트 요청 이벤트 발행\n      if (this.eventPublisher) {\n        await this.eventPublisher.publish(\n          new HintRequested(game.state.gameId, randomCell.position, hintValue, {\n            hintsUsed: updatedGame.state.hintsUsed,\n            hintType: 'random',\n            reasoning: `One of ${possibleValues.length} possible values`\n          })\n        );\n      }\n\n      await this.saveGame(updatedGame);\n\n      return {\n        success: true,\n        game: updatedGame,\n        position: randomCell.position,\n        value: hintValue\n      };\n    }\n\n    return null;\n  }\n\n  async selectCell(game: SudokuGame, position: Position): Promise<SudokuGame> {\n    const newState = game.state.selectCell(position.row, position.col);\n    const updatedGame = game.updateState(newState);\n    \n    await this.saveGame(updatedGame);\n    return updatedGame;\n  }\n\n  async clearSelection(game: SudokuGame): Promise<SudokuGame> {\n    const newState = game.state.clearSelection();\n    const updatedGame = game.updateState(newState);\n    \n    await this.saveGame(updatedGame);\n    return updatedGame;\n  }\n\n  async resetGame(game: SudokuGame): Promise<SudokuGame> {\n    const resetGame = game.reset();\n\n    // 게임 리셋 이벤트 발행\n    if (this.eventPublisher) {\n      await this.eventPublisher.publish(\n        new GameReset(game.state.gameId, {\n          previousStats: {\n            moveCount: game.state.moveCount,\n            mistakeCount: game.state.mistakeCount,\n            hintsUsed: game.state.hintsUsed,\n            elapsedTime: game.state.elapsedTime\n          }\n        })\n      );\n    }\n\n    await this.saveGame(resetGame);\n    return resetGame;\n  }\n\n  async pauseGame(game: SudokuGame): Promise<SudokuGame> {\n    const newState = game.state.pause();\n    const updatedGame = game.updateState(newState);\n\n    // 게임 일시정지 이벤트 발행\n    if (this.eventPublisher) {\n      await this.eventPublisher.publish(\n        new GamePaused(game.state.gameId, {\n          elapsedTime: updatedGame.state.elapsedTime,\n          moveCount: updatedGame.state.moveCount\n        })\n      );\n    }\n\n    await this.saveGame(updatedGame);\n    return updatedGame;\n  }\n\n  async resumeGame(game: SudokuGame): Promise<SudokuGame> {\n    const newState = game.state.resume();\n    const updatedGame = game.updateState(newState);\n\n    // 게임 재개 이벤트 발행\n    if (this.eventPublisher) {\n      await this.eventPublisher.publish(\n        new GameResumed(game.state.gameId, {\n          elapsedTime: updatedGame.state.elapsedTime,\n          moveCount: updatedGame.state.moveCount\n        })\n      );\n    }\n\n    await this.saveGame(updatedGame);\n    return updatedGame;\n  }\n\n  private generateGameId(): string {\n    return `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async generateSudokuGrid(difficulty: Difficulty): Promise<SudokuGrid> {\n    console.log(`Generating new ${difficulty} puzzle...`);\n\n    // 새로운 랜덤 시드로 생성기 초기화\n    const seed = Date.now() + Math.random() * 1000000;\n    const generator = new SudokuGeneratorService(seed);\n\n    // 난이도에 따른 퍼즐 생성\n    const puzzle = generator.generatePuzzle(difficulty, {\n      useSymmetricRemoval: difficulty === Difficulty.EASY // Easy는 대칭 제거로 더 예쁘게\n    });\n\n    console.log(`Successfully generated ${difficulty} puzzle with seed: ${seed}`);\n    return puzzle;\n  }\n\n}","import { GameRepository } from '../../domain/sudoku/repositories/GameRepository';\nimport { SudokuGame } from '../../domain/sudoku/aggregates/Game';\nimport { GameState, GameStatus, Difficulty } from '../../domain/sudoku/entities/GameState';\nimport { SudokuGrid } from '../../domain/sudoku/aggregates/Grid';\nimport { Cell } from '../../domain/sudoku/entities/Cell';\nimport { Position } from '../../domain/sudoku/value-objects/Position';\nimport { CellValue } from '../../domain/sudoku/value-objects/CellValue';\n\ninterface SerializedGame {\n  id: string;\n  grid: SerializedCell[][];\n  initialGrid: SerializedCell[][];\n  state: SerializedGameState;\n}\n\ninterface SerializedCell {\n  row: number;\n  col: number;\n  value: number | null;\n  isGiven: boolean;\n  isHighlighted: boolean;\n  hasError: boolean;\n}\n\ninterface SerializedGameState {\n  id: string;\n  difficulty: Difficulty;\n  status: GameStatus;\n  statistics: {\n    startTime: string;\n    endTime?: string;\n    elapsedTime: number;\n    moves: number;\n    hints: number;\n    mistakes: number;\n  };\n  selectedCell?: { row: number; col: number };\n}\n\nexport class LocalStorageGameRepository implements GameRepository {\n  private readonly STORAGE_PREFIX = 'sudoku_game_';\n  private readonly STATE_PREFIX = 'sudoku_state_';\n  private readonly GAMES_LIST_KEY = 'sudoku_games_list';\n\n  async save(game: SudokuGame): Promise<void> {\n    const serialized = this.serializeGame(game);\n    const key = this.STORAGE_PREFIX + game.id;\n    \n    localStorage.setItem(key, JSON.stringify(serialized));\n    \n    const gameIds = await this.getAllGameIds();\n    if (!gameIds.includes(game.id)) {\n      gameIds.push(game.id);\n      localStorage.setItem(this.GAMES_LIST_KEY, JSON.stringify(gameIds));\n    }\n  }\n\n  async load(gameId: string): Promise<SudokuGame | null> {\n    const key = this.STORAGE_PREFIX + gameId;\n    const data = localStorage.getItem(key);\n    \n    if (!data) {\n      return null;\n    }\n\n    try {\n      const serialized: SerializedGame = JSON.parse(data);\n      return this.deserializeGame(serialized);\n    } catch (error) {\n      console.error('Failed to deserialize game:', error);\n      return null;\n    }\n  }\n\n  async delete(gameId: string): Promise<void> {\n    const gameKey = this.STORAGE_PREFIX + gameId;\n    const stateKey = this.STATE_PREFIX + gameId;\n    \n    localStorage.removeItem(gameKey);\n    localStorage.removeItem(stateKey);\n    \n    const gameIds = await this.getAllGameIds();\n    const filteredIds = gameIds.filter(id => id !== gameId);\n    localStorage.setItem(this.GAMES_LIST_KEY, JSON.stringify(filteredIds));\n  }\n\n  async getAllGameIds(): Promise<string[]> {\n    const data = localStorage.getItem(this.GAMES_LIST_KEY);\n    return data ? JSON.parse(data) : [];\n  }\n\n  async saveGameState(gameId: string, state: GameState): Promise<void> {\n    const key = this.STATE_PREFIX + gameId;\n    const serialized = this.serializeGameState(state);\n    localStorage.setItem(key, JSON.stringify(serialized));\n  }\n\n  async loadGameState(gameId: string): Promise<GameState | null> {\n    const key = this.STATE_PREFIX + gameId;\n    const data = localStorage.getItem(key);\n    \n    if (!data) {\n      return null;\n    }\n\n    try {\n      const serialized: SerializedGameState = JSON.parse(data);\n      return this.deserializeGameState(serialized);\n    } catch (error) {\n      console.error('Failed to deserialize game state:', error);\n      return null;\n    }\n  }\n\n  private serializeGame(game: SudokuGame): SerializedGame {\n    return {\n      id: game.id,\n      grid: this.serializeGrid(game.grid),\n      initialGrid: this.serializeGrid(game.initialGrid),\n      state: this.serializeGameState(game.state)\n    };\n  }\n\n  private serializeGrid(grid: SudokuGrid): SerializedCell[][] {\n    return Array.from({ length: 9 }, (_, row) =>\n      Array.from({ length: 9 }, (_, col) => {\n        const cell = grid.getCell(new Position(row, col));\n        return {\n          row,\n          col,\n          value: cell.value.value,\n          isGiven: cell.isGiven,\n          isHighlighted: cell.isHighlighted,\n          hasError: cell.hasError\n        };\n      })\n    );\n  }\n\n  private serializeGameState(state: GameState): SerializedGameState {\n    return {\n      id: state.id,\n      difficulty: state.difficulty,\n      status: state.status,\n      statistics: {\n        startTime: state.statistics.startTime.toISOString(),\n        endTime: state.statistics.endTime?.toISOString(),\n        elapsedTime: state.statistics.elapsedTime,\n        moves: state.statistics.moves,\n        hints: state.statistics.hints,\n        mistakes: state.statistics.mistakes\n      },\n      selectedCell: state.selectedCell\n    };\n  }\n\n  private deserializeGame(serialized: SerializedGame): SudokuGame {\n    const grid = this.deserializeGrid(serialized.grid);\n    const initialGrid = this.deserializeGrid(serialized.initialGrid);\n    const state = this.deserializeGameState(serialized.state);\n    \n    return new SudokuGame(serialized.id, grid, initialGrid, state);\n  }\n\n  private deserializeGrid(serializedGrid: SerializedCell[][]): SudokuGrid {\n    const cells = serializedGrid.map(row =>\n      row.map(serializedCell => {\n        const position = new Position(serializedCell.row, serializedCell.col);\n        const value = serializedCell.value \n          ? CellValue.from(serializedCell.value) \n          : CellValue.empty();\n        \n        return new Cell(position, value, {\n          isGiven: serializedCell.isGiven,\n          isHighlighted: serializedCell.isHighlighted,\n          hasError: serializedCell.hasError\n        });\n      })\n    );\n    \n    return new SudokuGrid(cells);\n  }\n\n  private deserializeGameState(serialized: SerializedGameState): GameState {\n    return new GameState(\n      serialized.id,\n      serialized.difficulty,\n      serialized.status,\n      {\n        startTime: new Date(serialized.statistics.startTime),\n        endTime: serialized.statistics.endTime \n          ? new Date(serialized.statistics.endTime) \n          : undefined,\n        elapsedTime: serialized.statistics.elapsedTime,\n        moves: serialized.statistics.moves,\n        hints: serialized.statistics.hints,\n        mistakes: serialized.statistics.mistakes\n      },\n      serialized.selectedCell\n    );\n  }\n}","export interface BoardRenderOptions {\n  theme: 'light' | 'dark';\n  borderColor: string;\n  subGridBorderColor: string;\n  backgroundColor: string;\n}\n\nexport class BoardRenderer {\n  private borderWidth: number = 0.5;\n  private subGridBorderWidth: number = 3;\n  private outerBorderWidth: number = 3;\n\n  constructor(\n    private ctx: CanvasRenderingContext2D,\n    private cellSize: number,\n    private gridSize: number\n  ) {}\n\n  render(options: BoardRenderOptions): void {\n    this.drawBackground(options.backgroundColor);\n    this.drawCellBorders(options.borderColor);\n    this.drawSubGridBorders(options.subGridBorderColor);\n    this.drawOuterBorder(options.subGridBorderColor);\n  }\n\n  updateDimensions(cellSize: number, gridSize: number): void {\n    this.cellSize = cellSize;\n    this.gridSize = gridSize;\n  }\n\n  private drawBackground(backgroundColor: string): void {\n    this.ctx.fillStyle = backgroundColor;\n    this.ctx.fillRect(0, 0, this.gridSize, this.gridSize);\n  }\n\n  private drawCellBorders(borderColor: string): void {\n    this.ctx.strokeStyle = borderColor;\n    this.ctx.lineWidth = this.borderWidth;\n\n    // Draw vertical cell lines\n    for (let i = 0; i <= 9; i++) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(i * this.cellSize, 0);\n      this.ctx.lineTo(i * this.cellSize, this.gridSize);\n      this.ctx.stroke();\n    }\n\n    // Draw horizontal cell lines\n    for (let i = 0; i <= 9; i++) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, i * this.cellSize);\n      this.ctx.lineTo(this.gridSize, i * this.cellSize);\n      this.ctx.stroke();\n    }\n  }\n\n  private drawSubGridBorders(subGridBorderColor: string): void {\n    this.ctx.strokeStyle = subGridBorderColor;\n    this.ctx.lineWidth = this.subGridBorderWidth;\n\n    // Draw thick vertical lines for 3x3 sub-grids (내부만, 외곽선 제외)\n    for (let i = 3; i <= 6; i += 3) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(i * this.cellSize, 0);\n      this.ctx.lineTo(i * this.cellSize, this.gridSize);\n      this.ctx.stroke();\n    }\n\n    // Draw thick horizontal lines for 3x3 sub-grids (내부만, 외곽선 제외)\n    for (let i = 3; i <= 6; i += 3) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, i * this.cellSize);\n      this.ctx.lineTo(this.gridSize, i * this.cellSize);\n      this.ctx.stroke();\n    }\n  }\n\n  private drawOuterBorder(borderColor: string): void {\n    this.ctx.strokeStyle = borderColor;\n    this.ctx.lineWidth = this.outerBorderWidth;\n\n    // Draw outer border rectangle\n    this.ctx.beginPath();\n    this.ctx.rect(0, 0, this.gridSize, this.gridSize);\n    this.ctx.stroke();\n  }\n}","export interface SelectionEffect {\n  type: 'border' | 'highlight' | 'glow' | 'pulse';\n  color: string;\n  opacity: number;\n  intensity: number;\n}\n\nexport interface SelectionRenderOptions {\n  selectedCellEffect: SelectionEffect;\n  relatedCellsEffect: SelectionEffect;\n  numberHighlightEffect: SelectionEffect;\n  animationEnabled: boolean;\n  theme: 'light' | 'dark';\n}\n\nexport class SelectionEffectsRenderer {\n  private animationFrame: number | null = null;\n  private pulseTime: number = 0;\n\n  constructor(\n    private ctx: CanvasRenderingContext2D,\n    private cellSize: number\n  ) {}\n\n  renderSelection(\n    selectedRow: number, \n    selectedCol: number, \n    options: SelectionRenderOptions\n  ): void {\n    if (options.animationEnabled) {\n      this.renderAnimatedSelection(selectedRow, selectedCol, options);\n    } else {\n      this.renderStaticSelection(selectedRow, selectedCol, options);\n    }\n  }\n\n  renderRelatedCells(\n    selectedRow: number, \n    selectedCol: number, \n    options: SelectionRenderOptions\n  ): void {\n    this.highlightRow(selectedRow, selectedCol, options.relatedCellsEffect);\n    this.highlightColumn(selectedRow, selectedCol, options.relatedCellsEffect);\n    // 3x3 박스 하이라이트 제거됨\n  }\n\n  renderNumberHighlights(\n    selectedValue: number,\n    allCellsWithNumbers: Array<{row: number, col: number, value: number}>,\n    options: SelectionRenderOptions\n  ): void {\n    const matchingCells = allCellsWithNumbers.filter(cell => cell.value === selectedValue);\n    \n    for (const cell of matchingCells) {\n      this.highlightNumber(cell.row, cell.col, options.numberHighlightEffect);\n    }\n  }\n\n  updateDimensions(cellSize: number): void {\n    this.cellSize = cellSize;\n  }\n\n  startAnimation(): void {\n    this.pulseTime = Date.now();\n  }\n\n  stopAnimation(): void {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n\n  private renderStaticSelection(\n    selectedRow: number, \n    selectedCol: number, \n    options: SelectionRenderOptions\n  ): void {\n    const x = selectedCol * this.cellSize;\n    const y = selectedRow * this.cellSize;\n\n    switch (options.selectedCellEffect.type) {\n      case 'border':\n        this.drawSelectionBorder(x, y, options.selectedCellEffect);\n        break;\n      case 'highlight':\n        this.drawSelectionHighlight(x, y, options.selectedCellEffect);\n        break;\n      case 'glow':\n        this.drawSelectionGlow(x, y, options.selectedCellEffect);\n        break;\n    }\n  }\n\n  private renderAnimatedSelection(\n    selectedRow: number, \n    selectedCol: number, \n    options: SelectionRenderOptions\n  ): void {\n    const x = selectedCol * this.cellSize;\n    const y = selectedRow * this.cellSize;\n\n    if (options.selectedCellEffect.type === 'pulse') {\n      this.drawPulsingSelection(x, y, options.selectedCellEffect);\n    } else {\n      this.renderStaticSelection(selectedRow, selectedCol, options);\n    }\n  }\n\n  private drawSelectionBorder(x: number, y: number, effect: SelectionEffect): void {\n    this.ctx.strokeStyle = effect.color;\n    this.ctx.lineWidth = 3 + effect.intensity;\n    this.ctx.globalAlpha = effect.opacity;\n    \n    this.ctx.strokeRect(\n      x + 2, \n      y + 2, \n      this.cellSize - 4, \n      this.cellSize - 4\n    );\n    \n    this.ctx.globalAlpha = 1.0;\n  }\n\n  private drawSelectionHighlight(x: number, y: number, effect: SelectionEffect): void {\n    this.ctx.fillStyle = effect.color;\n    this.ctx.globalAlpha = effect.opacity;\n    \n    this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);\n    \n    this.ctx.globalAlpha = 1.0;\n  }\n\n  private drawSelectionGlow(x: number, y: number, effect: SelectionEffect): void {\n    const gradient = this.ctx.createRadialGradient(\n      x + this.cellSize / 2, \n      y + this.cellSize / 2, \n      0,\n      x + this.cellSize / 2, \n      y + this.cellSize / 2, \n      this.cellSize / 2 + effect.intensity\n    );\n    \n    gradient.addColorStop(0, effect.color);\n    gradient.addColorStop(1, 'transparent');\n    \n    this.ctx.fillStyle = gradient;\n    this.ctx.globalAlpha = effect.opacity;\n    \n    this.ctx.fillRect(\n      x - effect.intensity, \n      y - effect.intensity, \n      this.cellSize + 2 * effect.intensity, \n      this.cellSize + 2 * effect.intensity\n    );\n    \n    this.ctx.globalAlpha = 1.0;\n  }\n\n  private drawPulsingSelection(x: number, y: number, effect: SelectionEffect): void {\n    const elapsed = (Date.now() - this.pulseTime) / 1000;\n    const pulseValue = (Math.sin(elapsed * 3) + 1) / 2; // 0 to 1\n    \n    const dynamicOpacity = effect.opacity * (0.3 + pulseValue * 0.7);\n    const dynamicIntensity = effect.intensity * (0.8 + pulseValue * 0.4);\n    \n    const pulseEffect: SelectionEffect = {\n      ...effect,\n      opacity: dynamicOpacity,\n      intensity: dynamicIntensity\n    };\n    \n    this.drawSelectionBorder(x, y, pulseEffect);\n  }\n\n  private highlightRow(selectedRow: number, selectedCol: number, effect: SelectionEffect): void {\n    this.ctx.fillStyle = effect.color;\n    this.ctx.globalAlpha = effect.opacity;\n\n    for (let col = 0; col < 9; col++) {\n      if (col !== selectedCol) {\n        const x = col * this.cellSize;\n        const y = selectedRow * this.cellSize;\n        this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);\n      }\n    }\n\n    this.ctx.globalAlpha = 1.0;\n  }\n\n  private highlightColumn(selectedRow: number, selectedCol: number, effect: SelectionEffect): void {\n    this.ctx.fillStyle = effect.color;\n    this.ctx.globalAlpha = effect.opacity;\n\n    for (let row = 0; row < 9; row++) {\n      if (row !== selectedRow) {\n        const x = selectedCol * this.cellSize;\n        const y = row * this.cellSize;\n        this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);\n      }\n    }\n\n    this.ctx.globalAlpha = 1.0;\n  }\n\n  private highlightNumber(row: number, col: number, effect: SelectionEffect): void {\n    const x = col * this.cellSize;\n    const y = row * this.cellSize;\n\n    switch (effect.type) {\n      case 'highlight':\n        this.drawNumberHighlight(x, y, effect);\n        break;\n      case 'glow':\n        this.drawNumberGlow(x, y, effect);\n        break;\n      case 'border':\n        this.drawNumberBorder(x, y, effect);\n        break;\n    }\n  }\n\n  private drawNumberHighlight(x: number, y: number, effect: SelectionEffect): void {\n    // 셀 배경에 미묘한 색상 오버레이\n    this.ctx.fillStyle = effect.color;\n    this.ctx.globalAlpha = effect.opacity;\n    \n    this.ctx.fillRect(x + 2, y + 2, this.cellSize - 4, this.cellSize - 4);\n    \n    this.ctx.globalAlpha = 1.0;\n  }\n\n  private drawNumberGlow(x: number, y: number, effect: SelectionEffect): void {\n    // 숫자 주변에 글로우 효과\n    const gradient = this.ctx.createRadialGradient(\n      x + this.cellSize / 2, \n      y + this.cellSize / 2, \n      this.cellSize * 0.1,\n      x + this.cellSize / 2, \n      y + this.cellSize / 2, \n      this.cellSize * 0.4\n    );\n    \n    gradient.addColorStop(0, effect.color);\n    gradient.addColorStop(1, 'transparent');\n    \n    this.ctx.fillStyle = gradient;\n    this.ctx.globalAlpha = effect.opacity;\n    \n    this.ctx.fillRect(x, y, this.cellSize, this.cellSize);\n    \n    this.ctx.globalAlpha = 1.0;\n  }\n\n  private drawNumberBorder(x: number, y: number, effect: SelectionEffect): void {\n    // 숫자 셀 주위에 테두리\n    this.ctx.strokeStyle = effect.color;\n    this.ctx.lineWidth = 2;\n    this.ctx.globalAlpha = effect.opacity;\n    \n    this.ctx.strokeRect(x + 3, y + 3, this.cellSize - 6, this.cellSize - 6);\n    \n    this.ctx.globalAlpha = 1.0;\n  }\n\n  // 3x3 박스 하이라이트 메서드 - 현재 사용되지 않음\n  // private highlightSubGrid(selectedRow: number, selectedCol: number, effect: SelectionEffect): void {\n  //   this.ctx.fillStyle = effect.color;\n  //   this.ctx.globalAlpha = effect.opacity;\n\n  //   const boxStartRow = Math.floor(selectedRow / 3) * 3;\n  //   const boxStartCol = Math.floor(selectedCol / 3) * 3;\n\n  //   for (let row = boxStartRow; row < boxStartRow + 3; row++) {\n  //     for (let col = boxStartCol; col < boxStartCol + 3; col++) {\n  //       if (row !== selectedRow && col !== selectedCol) {\n  //         const x = col * this.cellSize;\n  //         const y = row * this.cellSize;\n  //         this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);\n  //       }\n  //     }\n  //   }\n\n  //   this.ctx.globalAlpha = 1.0;\n  // }\n}","import { LineCompletionEffect, CellEffectState } from '../../domain/effects/entities/LineCompletionEffect';\n\nexport interface EffectRenderOptions {\n  theme: 'light' | 'dark';\n  highlightColor?: string;\n  glowColor?: string;\n  animationDuration?: number;\n}\n\nexport class LineCompletionEffectsRenderer {\n  constructor(\n    private ctx: CanvasRenderingContext2D,\n    private cellSize: number\n  ) {}\n\n  updateDimensions(cellSize: number): void {\n    this.cellSize = cellSize;\n  }\n\n  renderEffects(effects: LineCompletionEffect[], options: EffectRenderOptions): void {\n    effects.forEach(effect => {\n      if (effect.isPlaying()) {\n        this.renderEffect(effect, options);\n      }\n    });\n  }\n\n  private renderEffect(effect: LineCompletionEffect, options: EffectRenderOptions): void {\n    const activeCells = effect.getActiveCellEffects();\n\n    activeCells.forEach(cellEffect => {\n      this.renderCellEffect(cellEffect, effect, options);\n    });\n  }\n\n  private renderCellEffect(cellEffect: CellEffectState, effect: LineCompletionEffect, options: EffectRenderOptions): void {\n    const progress = effect.getCellEffectProgress(cellEffect.position);\n    if (!progress) return;\n\n    const x = cellEffect.position.col * this.cellSize;\n    const y = cellEffect.position.row * this.cellSize;\n\n    this.renderScalingEffect(x, y, progress.scale, progress.opacity, options);\n  }\n\n  private renderScalingEffect(x: number, y: number, scale: number, opacity: number, options: EffectRenderOptions): void {\n    const centerX = x + this.cellSize / 2;\n    const centerY = y + this.cellSize / 2;\n    const scaledSize = this.cellSize * scale;\n    const scaledX = centerX - scaledSize / 2;\n    const scaledY = centerY - scaledSize / 2;\n\n    this.ctx.save();\n    this.ctx.globalAlpha = opacity * 0.7;\n\n    // Base color based on theme\n    const baseColor = options.theme === 'dark' ? '100, 150, 255' : '50, 120, 255'; // Blue\n\n    // Create gradient effect\n    const gradient = this.ctx.createRadialGradient(\n      centerX, centerY, 0,\n      centerX, centerY, scaledSize / 2\n    );\n\n    gradient.addColorStop(0, `rgba(${baseColor}, ${opacity})`);\n    gradient.addColorStop(0.7, `rgba(${baseColor}, ${opacity * 0.6})`);\n    gradient.addColorStop(1, `rgba(${baseColor}, 0)`);\n\n    // Draw the effect box\n    this.ctx.fillStyle = gradient;\n    this.ctx.fillRect(scaledX, scaledY, scaledSize, scaledSize);\n\n    // Add border effect\n    this.ctx.strokeStyle = `rgba(${baseColor}, ${opacity * 0.8})`;\n    this.ctx.lineWidth = Math.max(1, scale * 2);\n    this.ctx.strokeRect(scaledX, scaledY, scaledSize, scaledSize);\n\n    // Add subtle inner glow\n    this.ctx.shadowColor = `rgba(${baseColor}, ${opacity})`;\n    this.ctx.shadowBlur = scale * 5;\n    this.ctx.shadowOffsetX = 0;\n    this.ctx.shadowOffsetY = 0;\n    this.ctx.strokeRect(scaledX + 2, scaledY + 2, scaledSize - 4, scaledSize - 4);\n\n    this.ctx.restore();\n  }\n\n\n  // Helper method to check if any effects are currently playing\n  hasActiveEffects(effects: LineCompletionEffect[]): boolean {\n    return effects.some(effect => effect.isPlaying());\n  }\n\n  // Update effects and remove completed ones\n  updateEffects(effects: LineCompletionEffect[], currentTime: number): LineCompletionEffect[] {\n    return effects\n      .map(effect => effect.updateProgress(currentTime))\n      .filter(effect => !effect.isCompleted());\n  }\n}","import { GameRenderer, RenderOptions } from '../../infrastructure/rendering/GameRenderer';\nimport { SudokuGame } from '../../domain/sudoku/aggregates/Game';\nimport { Position } from '../../domain/sudoku/value-objects/Position';\nimport { Cell } from '../../domain/sudoku/entities/Cell';\nimport { BoardRenderer, BoardRenderOptions } from './BoardRenderer';\nimport { SelectionEffectsRenderer, SelectionRenderOptions } from './SelectionEffectsRenderer';\nimport { LineCompletionEffectsRenderer, EffectRenderOptions } from './LineCompletionEffectsRenderer';\nimport { LineCompletionEffect } from '../../domain/effects/entities/LineCompletionEffect';\n\nexport class CanvasGameRenderer implements GameRenderer {\n  private ctx: CanvasRenderingContext2D;\n  private cellSize: number = 0;\n  private gridSize: number = 0;\n\n  private boardRenderer: BoardRenderer;\n  private selectionRenderer: SelectionEffectsRenderer;\n  private effectsRenderer: LineCompletionEffectsRenderer;\n  private activeEffects: LineCompletionEffect[] = [];\n\n  constructor(\n    private canvas: HTMLCanvasElement,\n    private defaultOptions: RenderOptions = {\n      highlightErrors: true,\n      showPossibleValues: false,\n      theme: 'light'\n    }\n  ) {\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error('Could not get canvas 2D context');\n    }\n    this.ctx = context;\n    this.calculateDimensions();\n\n    // Initialize specialized renderers\n    this.boardRenderer = new BoardRenderer(this.ctx, this.cellSize, this.gridSize);\n    this.selectionRenderer = new SelectionEffectsRenderer(this.ctx, this.cellSize);\n    this.effectsRenderer = new LineCompletionEffectsRenderer(this.ctx, this.cellSize);\n  }\n\n  render(game: SudokuGame, options: Partial<RenderOptions> = {}): void {\n    const renderOptions = { ...this.defaultOptions, ...options };\n\n    // Update effects progress\n    this.updateEffects();\n\n    this.clear();\n    this.renderBoard(renderOptions);\n    this.renderCells(game, renderOptions);\n    this.renderEffects(renderOptions);\n    this.renderSelection(game, renderOptions);\n  }\n\n  getPositionFromCoords(x: number, y: number): Position | null {\n    console.log('Canvas dimensions:', this.canvas.width, this.canvas.height);\n    console.log('Cell size:', this.cellSize);\n    console.log('Input coordinates:', x, y);\n    \n    const col = Math.floor(x / this.cellSize);\n    const row = Math.floor(y / this.cellSize);\n    \n    console.log('Calculated row/col:', row, col);\n    \n    if (row >= 0 && row < 9 && col >= 0 && col < 9) {\n      try {\n        return new Position(row, col);\n      } catch (error) {\n        console.error('Position creation error:', error);\n        return null;\n      }\n    }\n    \n    console.log('Position out of bounds');\n    return null;\n  }\n\n  resize(width: number, height: number): void {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.calculateDimensions();\n    \n    // Update dimensions in specialized renderers\n    this.boardRenderer.updateDimensions(this.cellSize, this.gridSize);\n    this.selectionRenderer.updateDimensions(this.cellSize);\n    this.effectsRenderer.updateDimensions(this.cellSize);\n  }\n\n  clear(): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  private calculateDimensions(): void {\n    this.gridSize = Math.min(this.canvas.width, this.canvas.height);\n    this.cellSize = this.gridSize / 9;\n    console.log('Canvas dimensions calculated:', {\n      canvasWidth: this.canvas.width,\n      canvasHeight: this.canvas.height,\n      gridSize: this.gridSize,\n      cellSize: this.cellSize\n    });\n  }\n\n  private renderBoard(options: RenderOptions): void {\n    const boardOptions: BoardRenderOptions = {\n      theme: options.theme,\n      borderColor: options.theme === 'dark' ? '#555555' : '#e0e0e0',\n      subGridBorderColor: options.theme === 'dark' ? '#ffffff' : '#333333',\n      backgroundColor: options.theme === 'dark' ? '#2a2a2a' : '#ffffff'\n    };\n\n    this.boardRenderer.render(boardOptions);\n  }\n\n  private renderCells(game: SudokuGame, options: RenderOptions): void {\n    const selectedValue = this.getSelectedCellValue(game);\n    \n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        const position = new Position(row, col);\n        const cell = game.grid.getCell(position);\n        \n        const shouldHighlightNumber = selectedValue !== null && \n                                    !cell.isEmpty() && \n                                    cell.value.value === selectedValue;\n        \n        this.renderCell(cell, options, shouldHighlightNumber);\n      }\n    }\n  }\n\n  private getSelectedCellValue(game: SudokuGame): number | null {\n    if (!game.state.selectedCell) {\n      return null;\n    }\n    \n    const { row, col } = game.state.selectedCell;\n    const selectedCell = game.grid.getCell(new Position(row, col));\n    \n    return selectedCell.isEmpty() ? null : selectedCell.value.value!;\n  }\n\n  private renderCell(cell: Cell, options: RenderOptions, isHighlighted = false): void {\n    const x = cell.position.col * this.cellSize;\n    const y = cell.position.row * this.cellSize;\n\n    // Draw cell background\n    this.renderCellBackground(x, y, cell, options);\n\n    // Draw cell value\n    if (!cell.isEmpty()) {\n      this.renderCellValue(x, y, cell, options, isHighlighted);\n    }\n  }\n\n  private renderCellBackground(x: number, y: number, cell: Cell, options: RenderOptions): void {\n    let backgroundColor = options.theme === 'dark' ? '#2a2a2a' : '#ffffff';\n\n    if (cell.isGiven) {\n      backgroundColor = options.theme === 'dark' ? '#3a3a3a' : '#f0f0f0';\n    } else if (cell.hasError && options.highlightErrors) {\n      backgroundColor = options.theme === 'dark' ? '#4a2222' : '#ffe6e6';\n    }\n\n    this.ctx.fillStyle = backgroundColor;\n    this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);\n  }\n\n  private renderCellValue(x: number, y: number, cell: Cell, options: RenderOptions, isHighlighted = false): void {\n    this.ctx.font = `${Math.floor(this.cellSize * 0.6)}px Arial`;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n\n    let textColor = options.theme === 'dark' ? '#ffffff' : '#000000';\n    \n    if (cell.isGiven) {\n      textColor = options.theme === 'dark' ? '#cccccc' : '#333333';\n    } else if (cell.hasError && options.highlightErrors) {\n      textColor = options.theme === 'dark' ? '#ff6666' : '#cc0000';\n    }\n\n    // 하이라이트된 숫자는 특별한 색상 사용\n    if (isHighlighted) {\n      textColor = options.theme === 'dark' ? '#40E0D0' : '#FF8C00'; // 시안/오렌지\n      this.ctx.font = `bold ${Math.floor(this.cellSize * 0.6)}px Arial`; // 굵게\n      \n      // 글로우 효과 추가\n      this.ctx.shadowColor = textColor;\n      this.ctx.shadowBlur = 8;\n      this.ctx.shadowOffsetX = 0;\n      this.ctx.shadowOffsetY = 0;\n    }\n\n    this.ctx.fillStyle = textColor;\n    this.ctx.fillText(\n      cell.value.toString(),\n      x + this.cellSize / 2,\n      y + this.cellSize / 2\n    );\n\n    // 그림자 효과 리셋\n    if (isHighlighted) {\n      this.ctx.shadowBlur = 0;\n    }\n  }\n\n  private renderSelection(game: SudokuGame, options: RenderOptions): void {\n    if (!game.state.selectedCell) {\n      return;\n    }\n\n    const { row, col } = game.state.selectedCell;\n    const selectedCell = game.grid.getCell(new Position(row, col));\n\n    // Define selection effects based on theme\n    const selectionOptions: SelectionRenderOptions = {\n      selectedCellEffect: {\n        type: 'border',\n        color: options.theme === 'dark' ? '#4da6ff' : '#007bff',\n        opacity: 0.8,\n        intensity: 2\n      },\n      relatedCellsEffect: {\n        type: 'highlight',\n        color: options.theme === 'dark' ? 'rgba(77, 166, 255, 0.2)' : 'rgba(0, 123, 255, 0.15)',\n        opacity: 0.4,\n        intensity: 0\n      },\n      numberHighlightEffect: {\n        type: 'highlight',\n        // 미묘한 배경 하이라이트\n        color: options.theme === 'dark' ? 'rgba(64, 224, 208, 0.15)' : 'rgba(255, 140, 0, 0.2)',\n        opacity: 0.5,\n        intensity: 1\n      },\n      animationEnabled: true,\n      theme: options.theme\n    };\n\n    // Render related cells first (background)\n    this.selectionRenderer.renderRelatedCells(row, col, selectionOptions);\n    \n    // Render number highlights if selected cell has a number\n    if (!selectedCell.isEmpty()) {\n      const selectedValue = selectedCell.value.value!;\n      const allCellsWithNumbers = this.getAllCellsWithNumbers(game);\n      this.selectionRenderer.renderNumberHighlights(selectedValue, allCellsWithNumbers, selectionOptions);\n    }\n    \n    // Render selected cell (foreground)\n    this.selectionRenderer.renderSelection(row, col, selectionOptions);\n  }\n\n  private getAllCellsWithNumbers(game: SudokuGame): Array<{row: number, col: number, value: number}> {\n    const cellsWithNumbers: Array<{row: number, col: number, value: number}> = [];\n    \n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        const position = new Position(row, col);\n        const cell = game.grid.getCell(position);\n        \n        if (!cell.isEmpty()) {\n          cellsWithNumbers.push({\n            row,\n            col,\n            value: cell.value.value!\n          });\n        }\n      }\n    }\n    \n    return cellsWithNumbers;\n  }\n\n  // Effect management methods\n  addEffects(effects: LineCompletionEffect[]): void {\n    const startedEffects = effects.map(effect => effect.start());\n    this.activeEffects.push(...startedEffects);\n  }\n\n  hasActiveEffects(): boolean {\n    return this.effectsRenderer.hasActiveEffects(this.activeEffects);\n  }\n\n  private updateEffects(): void {\n    const currentTime = Date.now();\n    this.activeEffects = this.effectsRenderer.updateEffects(this.activeEffects, currentTime);\n  }\n\n  private renderEffects(options: RenderOptions): void {\n    if (this.activeEffects.length === 0) {\n      return;\n    }\n\n    const effectOptions: EffectRenderOptions = {\n      theme: options.theme,\n      highlightColor: options.theme === 'dark' ? 'rgba(255, 215, 0, 0.2)' : 'rgba(255, 140, 0, 0.25)',\n      glowColor: options.theme === 'dark' ? '#FFD700' : '#FF8C00',\n      animationDuration: 1500\n    };\n\n    this.effectsRenderer.renderEffects(this.activeEffects, effectOptions);\n  }\n}","import { GameService } from '../../application/services/GameService';\nimport { GameRenderer } from '../../infrastructure/rendering/GameRenderer';\nimport { SudokuGame } from '../../domain/sudoku/aggregates/Game';\nimport { Position } from '../../domain/sudoku/value-objects/Position';\nimport { CellValue } from '../../domain/sudoku/value-objects/CellValue';\nimport { Difficulty } from '../../domain/sudoku/entities/GameState';\nimport { LineCompletionEffect } from '../../domain/effects/entities/LineCompletionEffect';\nimport { CanvasGameRenderer } from '../renderers/CanvasGameRenderer';\n\nexport interface GameControllerEvents {\n  onGameUpdate: (game: SudokuGame) => void;\n  onGameComplete: (game: SudokuGame) => void;\n  onError: (error: string) => void;\n}\n\nexport class GameController {\n  private currentGame: SudokuGame | null = null;\n  private animationFrameId: number | null = null;\n\n  constructor(\n    private gameService: GameService,\n    private renderer: GameRenderer,\n    private events: GameControllerEvents\n  ) {}\n\n  async newGame(difficulty: Difficulty): Promise<void> {\n    try {\n      this.currentGame = await this.gameService.createNewGame(difficulty);\n      this.renderGame();\n      this.events.onGameUpdate(this.currentGame);\n    } catch (error) {\n      this.events.onError(`Failed to create new game: ${error}`);\n    }\n  }\n\n  async loadGame(gameId: string): Promise<void> {\n    try {\n      const game = await this.gameService.loadGame(gameId);\n      if (game) {\n        this.currentGame = game;\n        this.renderGame();\n        this.events.onGameUpdate(this.currentGame);\n      } else {\n        this.events.onError('Game not found');\n      }\n    } catch (error) {\n      this.events.onError(`Failed to load game: ${error}`);\n    }\n  }\n\n  async handleCellClick(x: number, y: number): Promise<void> {\n    console.log('GameController.handleCellClick called with:', x, y);\n    \n    if (!this.currentGame) {\n      console.log('No current game');\n      return;\n    }\n\n    const position = this.renderer.getPositionFromCoords(x, y);\n    console.log('Position from coords:', position);\n    \n    if (!position) {\n      console.log('Invalid position');\n      return;\n    }\n\n    try {\n      this.currentGame = await this.gameService.selectCell(this.currentGame, position);\n      console.log('Cell selected successfully, selected cell:', this.currentGame.state.selectedCell);\n      this.renderGame();\n      this.events.onGameUpdate(this.currentGame);\n    } catch (error) {\n      console.error('Error selecting cell:', error);\n      this.events.onError(`셀 선택에 실패했습니다: ${error}`);\n    }\n  }\n\n  async handleNumberInput(value: number): Promise<void> {\n    if (!this.currentGame?.state.selectedCell) {\n      this.events.onError('셀을 먼저 선택해주세요');\n      return;\n    }\n\n    try {\n      const { row, col } = this.currentGame.state.selectedCell;\n      const result = await this.gameService.makeMove(\n        this.currentGame, \n        new Position(row, col), \n        CellValue.from(value)\n      );\n\n      this.currentGame = result.game;\n\n      // Handle line completion effects\n      if (result.lineCompletionEffects && result.lineCompletionEffects.length > 0) {\n        this.handleLineCompletionEffects(result.lineCompletionEffects);\n      } else {\n        this.renderGame();\n      }\n\n      this.events.onGameUpdate(this.currentGame);\n\n      // 게임 완료 체크 로깅 추가\n      console.log('Game completion check:', {\n        isComplete: result.isComplete,\n        success: result.success,\n        filledCells: this.getFilledCellsCount(),\n        totalCells: 81\n      });\n\n      if (result.isComplete) {\n        console.log('🎉 Game completed! Calling onGameComplete...');\n        this.events.onGameComplete(this.currentGame);\n      } else if (!result.success) {\n        this.events.onError('잘못된 입력입니다');\n      }\n    } catch (error) {\n      this.events.onError(`Failed to make move: ${error}`);\n    }\n  }\n\n  async handleClearCell(): Promise<void> {\n    if (!this.currentGame) return;\n\n    if (!this.currentGame.state.selectedCell) {\n      this.events.onError('셀을 먼저 선택해주세요');\n      return;\n    }\n\n    try {\n      const { row, col } = this.currentGame.state.selectedCell;\n      const position = new Position(row, col);\n      \n      const result = await this.gameService.makeMove(\n        this.currentGame, \n        position, \n        CellValue.empty()\n      );\n\n      this.currentGame = result.game;\n\n      // Handle line completion effects from clear action\n      if (result.lineCompletionEffects && result.lineCompletionEffects.length > 0) {\n        this.handleLineCompletionEffects(result.lineCompletionEffects);\n      } else {\n        this.renderGame();\n      }\n\n      this.events.onGameUpdate(this.currentGame);\n    } catch (error) {\n      this.events.onError(`Failed to clear cell: ${error}`);\n    }\n  }\n\n  async handleHint(): Promise<void> {\n    if (!this.currentGame) return;\n\n    try {\n      const hint = await this.gameService.getHint(this.currentGame);\n      if (hint) {\n        // hint.game에는 이미 힌트 카운트가 증가된 상태\n        this.currentGame = hint.game;\n        \n        // Auto-fill the hint\n        const result = await this.gameService.makeMove(\n          this.currentGame,\n          hint.position,\n          hint.value\n        );\n\n        this.currentGame = result.game;\n\n        // Handle line completion effects from hint\n        if (result.lineCompletionEffects && result.lineCompletionEffects.length > 0) {\n          this.handleLineCompletionEffects(result.lineCompletionEffects);\n        } else {\n          this.renderGame();\n        }\n\n        this.events.onGameUpdate(this.currentGame);\n\n        if (result.isComplete) {\n          this.events.onGameComplete(this.currentGame);\n        }\n      } else {\n        this.events.onError('No hints available');\n      }\n    } catch (error) {\n      this.events.onError(`Failed to get hint: ${error}`);\n    }\n  }\n\n  async handleReset(): Promise<void> {\n    if (!this.currentGame) return;\n\n    try {\n      this.currentGame = await this.gameService.resetGame(this.currentGame);\n      this.renderGame();\n      this.events.onGameUpdate(this.currentGame);\n    } catch (error) {\n      this.events.onError(`Failed to reset game: ${error}`);\n    }\n  }\n\n  async handlePause(): Promise<void> {\n    if (!this.currentGame) return;\n\n    try {\n      this.currentGame = await this.gameService.pauseGame(this.currentGame);\n      this.renderGame();\n      this.events.onGameUpdate(this.currentGame);\n    } catch (error) {\n      this.events.onError(`Failed to pause game: ${error}`);\n    }\n  }\n\n  async handleResume(): Promise<void> {\n    if (!this.currentGame) return;\n\n    try {\n      this.currentGame = await this.gameService.resumeGame(this.currentGame);\n      this.renderGame();\n      this.events.onGameUpdate(this.currentGame);\n    } catch (error) {\n      this.events.onError(`Failed to resume game: ${error}`);\n    }\n  }\n\n  getCurrentGame(): SudokuGame | null {\n    return this.currentGame;\n  }\n\n  private getFilledCellsCount(): number {\n    if (!this.currentGame) return 0;\n\n    let count = 0;\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        const position = new Position(row, col);\n        const cell = this.currentGame.grid.getCell(position);\n        if (!cell.isEmpty()) {\n          count++;\n        }\n      }\n    }\n    return count;\n  }\n\n  private renderGame(): void {\n    if (this.currentGame) {\n      this.renderer.render(this.currentGame, {\n        highlightErrors: true,\n        showPossibleValues: false,\n        theme: 'light'\n      });\n    }\n  }\n\n  private handleLineCompletionEffects(effects: LineCompletionEffect[]): void {\n    if (this.renderer instanceof CanvasGameRenderer) {\n      this.renderer.addEffects(effects);\n      this.startEffectAnimation();\n    } else {\n      // Fallback for non-canvas renderers\n      this.renderGame();\n    }\n  }\n\n  private startEffectAnimation(): void {\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n    }\n\n    let lastFrameTime = 0;\n    const targetFPS = 60;\n    const frameInterval = 1000 / targetFPS;\n\n    const animate = (currentTime: number) => {\n      // Throttle to 60fps for better performance\n      if (currentTime - lastFrameTime >= frameInterval) {\n        this.renderGame();\n        lastFrameTime = currentTime;\n      }\n\n      if (this.renderer instanceof CanvasGameRenderer && this.renderer.hasActiveEffects()) {\n        this.animationFrameId = requestAnimationFrame(animate);\n      } else {\n        this.animationFrameId = null;\n      }\n    };\n\n    this.animationFrameId = requestAnimationFrame(animate);\n  }\n\n  destroy(): void {\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n  }\n}","/**\n * Manages DOM element access and manipulation\n * Provides a centralized way to access and update DOM elements with caching\n */\nexport class DOMElementManager {\n  private elementCache: Map<string, HTMLElement> = new Map();\n\n  /**\n   * Get a DOM element by its ID with type safety\n   * Caches elements to avoid repeated queries\n   */\n  getElement<T extends HTMLElement = HTMLElement>(elementId: string): T {\n    if (!this.elementCache.has(elementId)) {\n      const element = document.getElementById(elementId);\n      if (!element) {\n        throw new Error(`Element not found: ${elementId}`);\n      }\n      this.elementCache.set(elementId, element);\n    }\n    return this.elementCache.get(elementId) as T;\n  }\n\n  /**\n   * Get multiple elements by a CSS selector\n   */\n  getElements<T extends HTMLElement = HTMLElement>(selector: string): NodeListOf<T> {\n    return document.querySelectorAll<T>(selector);\n  }\n\n  /**\n   * Update text content of an element\n   */\n  updateTextContent(elementId: string, content: string): void {\n    const element = this.getElement(elementId);\n    element.textContent = content;\n  }\n\n  /**\n   * Update a CSS style property of an element\n   */\n  updateStyle(elementId: string, property: keyof CSSStyleDeclaration, value: string): void {\n    const element = this.getElement(elementId);\n    (element.style as any)[property] = value;\n  }\n\n  /**\n   * Update multiple style properties at once\n   */\n  updateStyles(elementId: string, styles: Partial<CSSStyleDeclaration>): void {\n    const element = this.getElement(elementId);\n    Object.entries(styles).forEach(([property, value]) => {\n      if (value !== undefined) {\n        (element.style as any)[property] = value;\n      }\n    });\n  }\n\n  /**\n   * Check if an element exists\n   */\n  elementExists(elementId: string): boolean {\n    try {\n      this.getElement(elementId);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if an element exists without caching it\n   */\n  hasElement(elementId: string): boolean {\n    return document.getElementById(elementId) !== null;\n  }\n\n  /**\n   * Clear the element cache\n   * Useful when DOM structure changes\n   */\n  clearCache(): void {\n    this.elementCache.clear();\n  }\n\n  /**\n   * Remove a specific element from cache\n   */\n  removeFromCache(elementId: string): void {\n    this.elementCache.delete(elementId);\n  }\n}","/**\n * DOM element selectors used throughout the application\n * Centralized to avoid hardcoded strings and improve maintainability\n */\nexport const DOM_SELECTORS = {\n  // Canvas\n  CANVAS: 'gameCanvas',\n\n  // Game statistics\n  TIMER: 'timer',\n  COMPLETION: 'completion',\n  HINTS: 'hints',\n\n  // User interface\n  SELECTION_INFO: 'selectionInfo',\n\n  // Control buttons\n  NEW_GAME_BTN: 'newGame',\n  RESET_GAME_BTN: 'resetGame',\n  HINT_BTN: 'hintButton',\n  CLEAR_CELL_BTN: 'clearCell',\n\n  // Number input\n  NUMBER_BTNS: '.number-btn'\n} as const;\n\n/**\n * Type for DOM selector keys\n */\nexport type DOMSelectorKey = keyof typeof DOM_SELECTORS;","import { GameController } from '@/presentation/controllers/GameController';\nimport { DOMElementManager } from './DOMElementManager';\nimport { DOM_SELECTORS } from '../config/DOMSelectors';\n\n/**\n * Manages all event listeners for the Sudoku application\n * Centralizes event handling logic for better maintainability\n */\nexport class EventManager {\n  private canvasEventHandler: CanvasEventHandler;\n  private keyboardEventHandler: KeyboardEventHandler;\n  private buttonEventHandler: ButtonEventHandler;\n\n  constructor(\n    gameController: GameController,\n    private domManager: DOMElementManager\n  ) {\n    const canvas = this.domManager.getElement<HTMLCanvasElement>(DOM_SELECTORS.CANVAS);\n\n    this.canvasEventHandler = new CanvasEventHandler(canvas, gameController);\n    this.keyboardEventHandler = new KeyboardEventHandler(gameController);\n    this.buttonEventHandler = new ButtonEventHandler(gameController, this.domManager);\n  }\n\n  /**\n   * Initialize all event listeners\n   */\n  setupEventListeners(): void {\n    this.canvasEventHandler.attachEvents();\n    this.keyboardEventHandler.attachEvents();\n    this.buttonEventHandler.attachEvents();\n  }\n\n  /**\n   * Remove all event listeners\n   */\n  removeEventListeners(): void {\n    this.canvasEventHandler.detachEvents();\n    this.keyboardEventHandler.detachEvents();\n    this.buttonEventHandler.detachEvents();\n  }\n}\n\n/**\n * Handles canvas click events and coordinate calculation\n */\nclass CanvasEventHandler {\n  constructor(\n    private canvas: HTMLCanvasElement,\n    private gameController: GameController\n  ) {}\n\n  private calculateCanvasCoordinates(event: MouseEvent): { x: number; y: number } {\n    const rect = this.canvas.getBoundingClientRect();\n    return {\n      x: ((event.clientX - rect.left) / rect.width) * this.canvas.width,\n      y: ((event.clientY - rect.top) / rect.height) * this.canvas.height\n    };\n  }\n\n  private handleCanvasClick = (event: MouseEvent): void => {\n    const { x, y } = this.calculateCanvasCoordinates(event);\n\n    console.log('Click event:', {\n      clientX: event.clientX,\n      clientY: event.clientY,\n      rect: this.canvas.getBoundingClientRect(),\n      canvas: { width: this.canvas.width, height: this.canvas.height },\n      calculated: { x, y }\n    });\n\n    // Use setTimeout to make cell click async and prevent UI blocking\n    setTimeout(() => {\n      this.gameController.handleCellClick(x, y);\n    }, 0);\n  };\n\n  attachEvents(): void {\n    this.canvas.addEventListener('click', this.handleCanvasClick);\n  }\n\n  detachEvents(): void {\n    this.canvas.removeEventListener('click', this.handleCanvasClick);\n  }\n}\n\n/**\n * Handles keyboard input events\n */\nclass KeyboardEventHandler {\n  constructor(private gameController: GameController) {}\n\n  private handleKeyDown = (event: KeyboardEvent): void => {\n    if (this.isNumberKey(event.key)) {\n      // Use setTimeout to make keyboard input async and prevent UI blocking\n      setTimeout(() => {\n        this.gameController.handleNumberInput(parseInt(event.key));\n      }, 0);\n    } else if (this.isClearKey(event.key)) {\n      // Use setTimeout to make clear cell async and prevent UI blocking\n      setTimeout(() => {\n        this.gameController.handleClearCell();\n      }, 0);\n    }\n  };\n\n  private isNumberKey(key: string): boolean {\n    return key >= '1' && key <= '9';\n  }\n\n  private isClearKey(key: string): boolean {\n    return key === 'Delete' || key === 'Backspace';\n  }\n\n  attachEvents(): void {\n    document.addEventListener('keydown', this.handleKeyDown);\n  }\n\n  detachEvents(): void {\n    document.removeEventListener('keydown', this.handleKeyDown);\n  }\n}\n\n/**\n * Handles button click events\n */\nclass ButtonEventHandler {\n  private eventHandlers: Map<string, () => void> = new Map();\n\n  constructor(\n    private gameController: GameController,\n    private domManager: DOMElementManager\n  ) {\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventHandlers.set(DOM_SELECTORS.NEW_GAME_BTN, () => {\n      setTimeout(() => this.handleNewGame(), 0);\n    });\n    this.eventHandlers.set(DOM_SELECTORS.RESET_GAME_BTN, () => {\n      setTimeout(() => this.gameController.handleReset(), 0);\n    });\n    this.eventHandlers.set(DOM_SELECTORS.HINT_BTN, () => {\n      setTimeout(() => this.gameController.handleHint(), 0);\n    });\n    this.eventHandlers.set(DOM_SELECTORS.CLEAR_CELL_BTN, () => {\n      setTimeout(() => this.gameController.handleClearCell(), 0);\n    });\n  }\n\n  private async handleNewGame(): Promise<void> {\n    // Import Difficulty here to avoid circular dependencies\n    const { Difficulty } = await import('@/domain/sudoku/entities/GameState.js');\n    await this.gameController.newGame(Difficulty.EASY);\n  }\n\n  private handleNumberButtonClick = (event: Event): void => {\n    const target = event.target as HTMLButtonElement;\n    const number = parseInt(target.dataset.number || '0');\n    if (number >= 1 && number <= 9) {\n      // Use setTimeout to make number button click async and prevent UI blocking\n      setTimeout(() => {\n        this.gameController.handleNumberInput(number);\n      }, 0);\n    }\n  };\n\n  attachEvents(): void {\n    // Attach control button events\n    this.eventHandlers.forEach((handler, elementId) => {\n      const element = this.domManager.getElement(elementId);\n      element.addEventListener('click', handler);\n    });\n\n    // Attach number button events\n    const numberButtons = this.domManager.getElements(DOM_SELECTORS.NUMBER_BTNS);\n    numberButtons.forEach(button => {\n      button.addEventListener('click', this.handleNumberButtonClick);\n    });\n  }\n\n  detachEvents(): void {\n    // Detach control button events\n    this.eventHandlers.forEach((handler, elementId) => {\n      if (this.domManager.elementExists(elementId)) {\n        const element = this.domManager.getElement(elementId);\n        element.removeEventListener('click', handler);\n      }\n    });\n\n    // Detach number button events\n    const numberButtons = this.domManager.getElements(DOM_SELECTORS.NUMBER_BTNS);\n    numberButtons.forEach(button => {\n      button.removeEventListener('click', this.handleNumberButtonClick);\n    });\n  }\n}","/**\n * Simple application configuration\n */\nexport const APP_CONFIG = {\n  // Timer settings\n  TIMER: {\n    INITIAL_DELAY: 100,\n    RESIZE_DELAY: 100,\n    ORIENTATION_CHANGE_DELAY: 200\n  },\n\n  // Game settings\n  GAME: {\n    GRID_SIZE: 9,\n    TOTAL_CELLS: 81,\n    DEFAULT_DIFFICULTY: 'EASY' as const\n  },\n\n  // UI settings\n  UI: {\n    MESSAGE_DURATION: 3000,\n    GAME_COMPLETE_DELAY: 1000,\n    CANVAS_ASPECT_RATIO: 1.0\n  }\n} as const;\n\n// Simple UI colors\nexport const UI_COLORS = {\n  ERROR: '#dc3545',\n  INFO: '#6c757d',\n  SUCCESS: '#28a745',\n  PRIMARY: '#007bff',\n  MUTED: '#6c757d'\n} as const;\n\n// Simple messages\nexport const MESSAGES = {\n  GAME_COMPLETE: '🎉 축하합니다! 퍼즐을 완성했습니다!',\n  SELECT_CELL: '칸을 선택하고 숫자를 입력하세요',\n  CELL_FIXED: '고정된 숫자입니다',\n  INPUT_NUMBER: '숫자를 입력하세요',\n  CELL_SELECTED: (row: number, col: number) => `선택된 셀: (${row + 1}, ${col + 1})`,\n  CELL_VALUE: (row: number, col: number, value: string) => `셀 (${row + 1}, ${col + 1}): ${value}`,\n  GAME_STATS: (time: string, moves: number, hints: number) =>\n    `완료 시간: ${time}\\n움직임: ${moves}\\n힌트: ${hints}`\n} as const;\n\n","import { SudokuGame } from '@/domain/sudoku/aggregates/Game';\nimport { Position } from '@/domain/sudoku/value-objects/Position';\nimport { DOMElementManager } from './DOMElementManager';\nimport { DOM_SELECTORS } from '../config/DOMSelectors';\nimport { APP_CONFIG, UI_COLORS, MESSAGES } from '../config/AppConfig';\n\n/**\n * Interface for UI update operations\n */\ninterface UIUpdate {\n  elementId: string;\n  content: string;\n  style?: Partial<CSSStyleDeclaration>;\n}\n\n/**\n * Manages all UI updates and display logic\n * Centralizes DOM manipulation for game state visualization\n */\nexport class UIManager {\n  constructor(private domManager: DOMElementManager) {}\n\n  /**\n   * Update game statistics display\n   */\n  updateGameInfo(game: SudokuGame, currentElapsedTime?: string): void {\n    const stats = game.state.statistics;\n    const filledCells = this.getFilledCellsCount(game);\n\n    const updates: UIUpdate[] = [\n      {\n        elementId: DOM_SELECTORS.COMPLETION,\n        content: `${filledCells}/${APP_CONFIG.GAME.TOTAL_CELLS}`\n      },\n      {\n        elementId: DOM_SELECTORS.HINTS,\n        content: stats.hints.toString()\n      }\n    ];\n\n    // Update timer if provided\n    if (currentElapsedTime) {\n      updates.push({\n        elementId: DOM_SELECTORS.TIMER,\n        content: currentElapsedTime\n      });\n    }\n\n    this.batchUpdate(updates);\n  }\n\n  /**\n   * Update selection information display\n   */\n  updateSelectionInfo(game: SudokuGame): void {\n    const selectionInfo = game.state.selectedCell;\n    let message: string;\n    let color: string;\n\n    if (!selectionInfo) {\n      message = MESSAGES.SELECT_CELL;\n      color = UI_COLORS.INFO;\n    } else {\n      const { row, col } = selectionInfo;\n      const cell = game.grid.getCell(new Position(row, col));\n\n      if (cell.isGiven) {\n        message = `${MESSAGES.CELL_SELECTED(row, col)} - ${MESSAGES.CELL_FIXED}`;\n        color = UI_COLORS.MUTED;\n      } else if (!cell.isEmpty()) {\n        message = MESSAGES.CELL_VALUE(row, col, cell.value.toString());\n        color = UI_COLORS.PRIMARY;\n      } else {\n        message = `${MESSAGES.CELL_SELECTED(row, col)} - ${MESSAGES.INPUT_NUMBER}`;\n        color = UI_COLORS.SUCCESS;\n      }\n    }\n\n    this.batchUpdate([{\n      elementId: DOM_SELECTORS.SELECTION_INFO,\n      content: message,\n      style: { color }\n    }]);\n  }\n\n  /**\n   * Show a temporary message with optional auto-clear\n   */\n  showMessage(\n    message: string,\n    type: keyof typeof UI_COLORS = 'INFO',\n    duration: number = 0\n  ): void {\n    const color = UI_COLORS[type];\n\n    this.batchUpdate([{\n      elementId: DOM_SELECTORS.SELECTION_INFO,\n      content: message,\n      style: { color }\n    }]);\n\n    if (duration > 0) {\n      setTimeout(() => {\n        // This would need access to current game state to restore selection info\n        // For now, just reset to default message\n        this.batchUpdate([{\n          elementId: DOM_SELECTORS.SELECTION_INFO,\n          content: MESSAGES.SELECT_CELL,\n          style: { color: UI_COLORS.INFO }\n        }]);\n      }, duration);\n    }\n  }\n\n  /**\n   * Show game completion dialog\n   */\n  showGameComplete(game: SudokuGame, finalTime: string): void {\n    console.log('UIManager.showGameComplete called!', {\n      finalTime,\n      gameStats: game.state.statistics\n    });\n\n    const stats = game.state.statistics;\n    const message = `${MESSAGES.GAME_COMPLETE}\\n\\n${MESSAGES.GAME_STATS(finalTime, stats.moves, stats.hints)}`;\n\n    console.log('About to show alert with message:', message);\n\n    setTimeout(() => {\n      console.log('Showing game complete alert now!');\n      alert(message);\n    }, APP_CONFIG.UI.GAME_COMPLETE_DELAY);\n  }\n\n  /**\n   * Perform multiple UI updates in a batch\n   */\n  private batchUpdate(updates: UIUpdate[]): void {\n    updates.forEach(update => {\n      try {\n        this.domManager.updateTextContent(update.elementId, update.content);\n\n        if (update.style) {\n          this.domManager.updateStyles(update.elementId, update.style);\n        }\n      } catch (error) {\n        console.warn(`Failed to update element ${update.elementId}:`, error);\n      }\n    });\n  }\n\n  /**\n   * Count filled cells in the current game\n   */\n  private getFilledCellsCount(game: SudokuGame): number {\n    let count = 0;\n    for (let row = 0; row < APP_CONFIG.GAME.GRID_SIZE; row++) {\n      for (let col = 0; col < APP_CONFIG.GAME.GRID_SIZE; col++) {\n        const position = new Position(row, col);\n        const cell = game.grid.getCell(position);\n        if (!cell.isEmpty()) {\n          count++;\n        }\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Update timer display\n   */\n  updateTimer(formattedTime: string): void {\n    this.domManager.updateTextContent(DOM_SELECTORS.TIMER, formattedTime);\n  }\n\n  /**\n   * Update number button counts and states\n   */\n  updateNumberButtons(game: SudokuGame): void {\n    const remainingCounts = game.grid.getRemainingCounts();\n\n    for (let num = 1; num <= 9; num++) {\n      const remaining = remainingCounts.get(num) || 0;\n      const buttonSelector = `[data-number=\"${num}\"]`;\n      const countSelector = `[data-number=\"${num}\"] .number-count`;\n\n      try {\n        // Update count display\n        const countElement = document.querySelector(countSelector) as HTMLElement;\n        if (countElement) {\n          countElement.textContent = remaining.toString();\n        }\n\n        // Update button state\n        const buttonElement = document.querySelector(buttonSelector) as HTMLButtonElement;\n        if (buttonElement) {\n          if (remaining === 0) {\n            buttonElement.disabled = true;\n            buttonElement.setAttribute('aria-disabled', 'true');\n          } else {\n            buttonElement.disabled = false;\n            buttonElement.removeAttribute('aria-disabled');\n          }\n        }\n      } catch (error) {\n        console.warn(`Failed to update number button ${num}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Reset all UI to initial state\n   */\n  resetUI(): void {\n    this.batchUpdate([\n      {\n        elementId: DOM_SELECTORS.TIMER,\n        content: '00:00'\n      },\n      {\n        elementId: DOM_SELECTORS.COMPLETION,\n        content: `0/${APP_CONFIG.GAME.TOTAL_CELLS}`\n      },\n      {\n        elementId: DOM_SELECTORS.HINTS,\n        content: '0'\n      },\n      {\n        elementId: DOM_SELECTORS.SELECTION_INFO,\n        content: MESSAGES.SELECT_CELL,\n        style: { color: UI_COLORS.INFO }\n      }\n    ]);\n\n    // Reset number button counts and enable all buttons\n    for (let num = 1; num <= 9; num++) {\n      const buttonSelector = `[data-number=\"${num}\"]`;\n      const countSelector = `[data-number=\"${num}\"] .number-count`;\n\n      try {\n        const countElement = document.querySelector(countSelector) as HTMLElement;\n        if (countElement) {\n          countElement.textContent = '9';\n        }\n\n        const buttonElement = document.querySelector(buttonSelector) as HTMLButtonElement;\n        if (buttonElement) {\n          buttonElement.disabled = false;\n          buttonElement.removeAttribute('aria-disabled');\n        }\n      } catch (error) {\n        console.warn(`Failed to reset number button ${num}:`, error);\n      }\n    }\n  }\n}","/**\n * Common utility functions used across the application\n */\n\n/**\n * Format time in seconds to MM:SS format\n */\nexport function formatTime(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Create a 9x9 grid with a factory function\n */\nexport function create9x9Grid<T>(factory: (row: number, col: number) => T): T[][] {\n  return Array.from({ length: 9 }, (_, row) =>\n    Array.from({ length: 9 }, (_, col) => factory(row, col))\n  );\n}\n\n/**\n * Deep clone a 2D array\n */\nexport function cloneGrid<T>(grid: T[][]): T[][] {\n  return grid.map(row => [...row]);\n}","import { SudokuGame } from '@/domain/sudoku/aggregates/Game';\nimport { formatTime } from '../../utils/index';\n\n/**\n * Manages game timer functionality\n * Uses requestAnimationFrame for smoother, independent timer updates\n */\nexport class TimerManager {\n  private animationFrameId: number | null = null;\n  private startTime: Date | null = null;\n  private lastDisplayedSeconds: number = -1;\n\n  constructor(private onTimeUpdate: (formattedTime: string) => void) {}\n\n  /**\n   * Start the timer for a game\n   */\n  start(game: SudokuGame): void {\n    // Don't restart if already running with the same start time\n    if (this.isRunning() && this.startTime &&\n        this.startTime.getTime() === game.state.statistics.startTime.getTime()) {\n      return;\n    }\n\n    this.stop(); // Clear any existing timer\n    this.startTime = game.state.statistics.startTime;\n    this.lastDisplayedSeconds = -1;\n    this.tick();\n  }\n\n  /**\n   * Stop the timer\n   */\n  stop(): void {\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n  }\n\n  /**\n   * Timer tick using requestAnimationFrame for smooth updates\n   */\n  private tick = (): void => {\n    const elapsedSeconds = this.getElapsedSeconds();\n\n    // Only update UI when seconds actually change to avoid unnecessary updates\n    if (elapsedSeconds !== this.lastDisplayedSeconds) {\n      const formattedTime = formatTime(elapsedSeconds);\n      this.onTimeUpdate(formattedTime);\n      this.lastDisplayedSeconds = elapsedSeconds;\n    }\n\n    // Continue the timer loop\n    this.animationFrameId = requestAnimationFrame(this.tick);\n  };\n\n  /**\n   * Get current elapsed seconds\n   */\n  getElapsedSeconds(): number {\n    if (!this.startTime) return 0;\n    return Math.floor((Date.now() - this.startTime.getTime()) / 1000);\n  }\n\n  /**\n   * Get formatted elapsed time string\n   */\n  getFormattedElapsedTime(): string {\n    return formatTime(this.getElapsedSeconds());\n  }\n\n  /**\n   * Check if timer is currently running\n   */\n  isRunning(): boolean {\n    return this.animationFrameId !== null;\n  }\n\n  /**\n   * Clean up timer resources\n   * Should be called when TimerManager is no longer needed\n   */\n  destroy(): void {\n    this.stop();\n    this.startTime = null;\n  }\n\n  /**\n   * Reset timer state without starting\n   */\n  reset(): void {\n    this.stop();\n    this.startTime = null;\n    this.lastDisplayedSeconds = -1;\n    this.onTimeUpdate(formatTime(0));\n  }\n}","import { GameService } from './application/services/GameService';\nimport { SudokuValidationService } from './domain/sudoku/services/GridValidationService';\nimport { LocalStorageGameRepository } from './infrastructure/repositories/LocalStorageGameRepository';\nimport { CanvasGameRenderer } from './presentation/renderers/CanvasGameRenderer';\nimport { GameController } from './presentation/controllers/GameController';\nimport { SudokuGame } from './domain/sudoku/aggregates/Game';\n\n// Import new manager classes\nimport { DOMElementManager } from './presentation/managers/DOMElementManager';\nimport { EventManager } from './presentation/managers/EventManager';\nimport { UIManager } from './presentation/managers/UIManager';\nimport { TimerManager } from './presentation/managers/TimerManager';\n\n// Import configuration\nimport { DOM_SELECTORS } from './presentation/config/DOMSelectors';\nimport { APP_CONFIG } from './presentation/config/AppConfig';\n\n/**\n * Main application class - now focused only on orchestration\n * Business logic has been delegated to specialized manager classes\n */\nclass SudokuApp {\n  private gameController!: GameController;\n  private domManager!: DOMElementManager;\n  private eventManager!: EventManager;\n  private uiManager!: UIManager;\n  private timerManager!: TimerManager;\n  private canvas!: HTMLCanvasElement;\n  private renderer!: CanvasGameRenderer;\n\n  constructor() {\n    this.initializeDependencies();\n    this.setupManagers();\n    this.setupCanvas();\n    this.startNewGame();\n  }\n\n  /**\n   * Initialize core dependencies using dependency injection\n   */\n  private initializeDependencies(): void {\n    // Repository and services\n    const gameRepository = new LocalStorageGameRepository();\n    const validationService = new SudokuValidationService();\n    const gameService = new GameService(gameRepository, validationService);\n\n    // Canvas and renderer\n    this.canvas = document.getElementById(DOM_SELECTORS.CANVAS) as HTMLCanvasElement;\n    if (!this.canvas) {\n      throw new Error('Canvas element not found');\n    }\n    this.renderer = new CanvasGameRenderer(this.canvas);\n\n    // Game controller with callbacks\n    this.gameController = new GameController(gameService, this.renderer, {\n      onGameUpdate: (game) => this.handleGameUpdate(game),\n      onGameComplete: (game) => this.handleGameComplete(game),\n      onError: (error) => this.handleError(error)\n    });\n  }\n\n  /**\n   * Initialize and connect all manager classes\n   */\n  private setupManagers(): void {\n    // DOM element manager\n    this.domManager = new DOMElementManager();\n\n    // Timer manager with UI update callback\n    this.timerManager = new TimerManager((formattedTime) => {\n      this.uiManager.updateTimer(formattedTime);\n    });\n\n    // UI manager\n    this.uiManager = new UIManager(this.domManager);\n\n    // Event manager (must be last as it depends on other managers)\n    this.eventManager = new EventManager(this.gameController, this.domManager);\n    this.eventManager.setupEventListeners();\n  }\n\n  /**\n   * Setup responsive canvas behavior\n   */\n  private setupCanvas(): void {\n    this.setupResponsiveCanvas();\n  }\n\n  /**\n   * Start a new game with default difficulty\n   */\n  private async startNewGame(): Promise<void> {\n    const { Difficulty } = await import('./domain/sudoku/entities/GameState.js');\n    await this.gameController.newGame(Difficulty.EASY);\n  }\n\n  /**\n   * Handle game state updates\n   */\n  private handleGameUpdate(game: SudokuGame): void {\n    this.uiManager.updateGameInfo(game);\n    this.uiManager.updateSelectionInfo(game);\n    this.uiManager.updateNumberButtons(game);\n    this.timerManager.start(game);\n  }\n\n  /**\n   * Handle game completion\n   */\n  private handleGameComplete(game: SudokuGame): void {\n    console.log('🎉 handleGameComplete called!', {\n      gameId: game.state.gameId,\n      isComplete: game.state.isComplete,\n      statistics: game.state.statistics\n    });\n\n    // Stop timer and get final time\n    this.timerManager.stop();\n    const finalTime = this.timerManager.getFormattedElapsedTime();\n\n    console.log('Final time and stats:', {\n      finalTime,\n      moves: game.state.statistics.moves,\n      hints: game.state.statistics.hints\n    });\n\n    // Update UI with final stats\n    this.uiManager.updateGameInfo(game, finalTime);\n    this.uiManager.showGameComplete(game, finalTime);\n  }\n\n  /**\n   * Handle errors\n   */\n  private handleError(error: string): void {\n    this.uiManager.showMessage(error, 'ERROR', APP_CONFIG.UI.MESSAGE_DURATION);\n  }\n\n  /**\n   * Setup responsive canvas with proper scaling\n   */\n  private setupResponsiveCanvas(): void {\n    const resizeGame = () => {\n      const rect = this.canvas.getBoundingClientRect();\n      const canvasSize = Math.min(rect.width, rect.height);\n      const devicePixelRatio = window.devicePixelRatio || 1;\n      const internalSize = Math.floor(canvasSize * devicePixelRatio);\n\n      console.log('Responsive canvas resize:', {\n        cssSize: { width: rect.width, height: rect.height },\n        canvasSize,\n        devicePixelRatio,\n        internalSize,\n        timestamp: new Date().toISOString()\n      });\n\n      // Set canvas internal resolution\n      this.canvas.width = internalSize;\n      this.canvas.height = internalSize;\n\n      // Notify renderer of size change\n      this.renderer.resize(internalSize, internalSize);\n\n      // Re-render current game\n      const currentGame = this.gameController.getCurrentGame();\n      if (currentGame) {\n        this.renderer.render(currentGame, {\n          highlightErrors: true,\n          showPossibleValues: false,\n          theme: 'light'\n        });\n      }\n    };\n\n    // Initial resize with delay for DOM to be ready\n    setTimeout(resizeGame, APP_CONFIG.TIMER.INITIAL_DELAY);\n\n    // Window resize events\n    window.addEventListener('resize', () => {\n      setTimeout(resizeGame, APP_CONFIG.TIMER.RESIZE_DELAY);\n    });\n\n    // Orientation change events (mobile)\n    window.addEventListener('orientationchange', () => {\n      setTimeout(resizeGame, APP_CONFIG.TIMER.ORIENTATION_CHANGE_DELAY);\n    });\n  }\n\n  /**\n   * Clean up resources when app is destroyed\n   */\n  destroy(): void {\n    this.eventManager.removeEventListeners();\n    this.timerManager.destroy();\n    this.domManager.clearCache();\n  }\n}\n\n// Initialize the app when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  try {\n    new SudokuApp();\n  } catch (error) {\n    console.error('Failed to initialize Sudoku app:', error);\n  }\n});"],"file":"assets/index-65a6690b.js"}